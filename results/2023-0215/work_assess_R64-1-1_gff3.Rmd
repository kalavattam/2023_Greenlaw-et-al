---
title: "work_assess_R64-1-1_gff3.Rmd"
output: html_notebookauthor: "KA"
email: "kalavatt@fredhutch.org"
output:
    html_notebook:
        toc: yes
        toc_float: true
---
<br />

Want to see how this file from SGD differs from the Ensembl 108 file we have been using
`#TODO` Include file names, more info

## Get situated
### Code
<details>
<summary><i>Code: Get situated</i></summary>
```{r}
#!/usr/bin/env Rscript

library(GenomicRanges)
library(IRanges)
library(plyr)
library(readxl)
library(rtracklayer)
library(tidyverse)

options(scipen = 999)
options(ggrepel.max.overlaps = Inf)

if(stringr::str_detect(getwd(), "kalavattam")) {
    p_local <- "/Users/kalavattam/Dropbox/FHCC"
} else {
    p_local <- "/Users/kalavatt/projects-etc"
}
p_wd <- "2022_transcriptome-construction/results/2023-0215"

setwd(paste(p_local, p_wd, sep = "/"))
getwd()

rm(p_local, p_wd)
```
</details>
<br />
<br />

## Load `gtf`, `gff3` files
### Code
<details>
<summary><i>Code: Load "R64" (`saccharomyces_cerevisiae_R64-1-1_20110208.gff`)</i></summary>
```{r Load "R64", results='hide', message=FALSE, warning=FALSE}
p_SGD <- "./infiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203"
f_SGD <- "saccharomyces_cerevisiae_R64-1-1_20110208.gff"
gff3_SGD <- paste(p_SGD, f_SGD, sep = "/") %>%
    rtracklayer::import() %>%
    tibble::as_tibble() %>%
    dplyr::arrange(seqnames, start) %>%
    dplyr::mutate(seqnames = gsub("chr", "", seqnames))

rm(p_SGD, f_SGD)

p_Ens <- "./infiles_gtf-gff3/already"
f_Ens <- "Saccharomyces_cerevisiae.R64-1-1.108.gff3"
gff3_Ens <- paste(p_Ens, f_Ens, sep = "/") %>%
    rtracklayer::import() %>%
    tibble::as_tibble() %>%
    dplyr::arrange(seqnames, start)

rm(p_Ens, f_Ens)

p_Ens <- "./infiles_gtf-gff3/already"
f_Ens <- "Saccharomyces_cerevisiae.R64-1-1.108.gtf"
gtf_Ens <- paste(p_Ens, f_Ens, sep = "/") %>%
    rtracklayer::import() %>%
    tibble::as_tibble() %>%
    dplyr::arrange(seqnames, start)

rm(p_Ens, f_Ens)
```
</details>
<br />
<br />

## Perform comparisons
### Are the numbers of sn/snoRNA features per `gtf`/`gff3` the same?
#### Code
<details>
<summary><i>Code: Are the numbers of sn/snoRNA features per `gtf`/`gff3` the same?</i></summary>
```{r Are the numbers of sn/snoRNA features per gtf/gff3 the same?, results='hide', message=FALSE, warning=FALSE}
gff3_SGD %>% colnames()
gff3_Ens %>% colnames()
gtf_Ens %>% colnames()

type_gff3_SGD <- gff3_SGD %>%
    dplyr::group_by(type) %>%
    dplyr::summarize(n = dplyr::n())

type_gff3_Ens <- gff3_Ens %>%
    dplyr::group_by(type) %>% 
    dplyr::summarize(n = dplyr::n())

type_gtf_Ens <- gtf_Ens %>%
    dplyr::group_by(type) %>% 
    dplyr::summarize(n = dplyr::n())

biotype_gff3_SGD <- gff3_SGD %>%
    dplyr::group_by(type) %>%
    dplyr::summarize(n = dplyr::n())

biotype_gff3_Ens <- gff3_Ens %>%
    dplyr::group_by(biotype) %>% 
    dplyr::summarize(n = dplyr::n())

biotype_gtf_Ens <- gtf_Ens %>%
    dplyr::group_by(gene_biotype) %>% 
    dplyr::summarize(n = dplyr::n())
```
</details>
<br />

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
#  Initialize function --------------------------------------------------------
`%notin%` <- Negate(`%in%`)


#  For the SGD gff3, subset by column "type" entry "gene" ---------------------
z_gff3_SGD_genes <- gff3_SGD %>%
    dplyr::filter(type == "gene")

#  Tally number of genes per chromosome
# z_gff3_SGD_genes %>%
#     dplyr::group_by(seqnames) %>%
#     dplyr::summarize(n = dplyr::n())

z_gff3_Ens_genes_summary <- gff3_Ens %>%
    dplyr::filter(type == "gene") %>%
    dplyr::group_by(seqnames) %>%
    dplyr::summarize(n = dplyr::n())

z_gff3_Ens_genes_summary_sum <- sum(z_gff3_Ens_genes_summary$n)


#  For the Ensembl gff3, subset by column "type" entry "gene" -----------------
z_gff3_Ens_genes <- gff3_Ens %>%
    dplyr::filter(type == "gene") %>%
    dplyr::group_by(seqnames)

z_gff3_SGD_genes$ID %notin%
    stringr::str_remove(z_gff3_Ens_genes$ID, "gene:") %>%
table()


#  Find gene IDs in SGD not in Ensembl ----------------------------------------
z_gff3_SGD_genes[z_gff3_SGD_genes$ID %notin%
        stringr::str_remove(z_gff3_Ens_genes$ID, "gene:"), ]$ID
# [1] "YER109C" "YFL057C" "YFL056C" "YOR031W" "R0010W"  "R0020C"  "R0030W"  "R0040C"

#  (column ID) ------------------------
c("YER109C", "YFL057C", "YFL056C", "YOR031W") %in%
    stringr::str_remove(gff3_Ens$ID, "gene:|CDS:|transcript:")
# [1] FALSE FALSE  TRUE FALSE

gff3_Ens[stringr::str_remove(gff3_Ens$ID, "gene:|CDS:|transcript:") %in%
    c("YER109C", "YFL057C", "YFL056C", "YOR031W"), ]

#  (column protein_ID) ----------------
c("YER109C", "YFL057C", "YFL056C", "YOR031W") %in% gff3_Ens$protein_id
# [1] FALSE FALSE FALSE FALSE

# gff3_Ens[gff3_Ens$protein_id %in%
#     c("YER109C", "YFL057C", "YFL056C", "YOR031W"), ]

#  (column gene_id) -------------------
c("YER109C", "YFL057C", "YFL056C", "YOR031W") %in% gff3_Ens$gene_id
# [1] FALSE FALSE TRUE FALSE

gff3_Ens[gff3_Ens$gene_id %in%
    c("YER109C", "YFL057C", "YFL056C", "YOR031W"), ]

#  (column transcript_id) -------------
c("YER109C", "YFL057C", "YFL056C", "YOR031W") %in% gff3_Ens$transcript_id
# [1] FALSE FALSE TRUE FALSE

gff3_Ens[gff3_Ens$transcript_id %in%
    c("YER109C", "YFL057C", "YFL056C", "YOR031W"), ]


#  Find any rows associated with "YER109C", "YFL057C", "YFL056C", "YOR031W" ---
library(data.table)
gff3_Ens[apply(gff3_Ens, 1, function(x) any(x %like% "YER109C")), ]  # 0 rows
gff3_Ens[apply(gff3_Ens, 1, function(x) any(x %like% "YFL057C")), ]  # 1 row (in row for "YFL056C")
gff3_Ens[apply(gff3_Ens, 1, function(x) any(x %like% "YFL056C")), ]  # 3 rows
gff3_Ens[apply(gff3_Ens, 1, function(x) any(x %like% "YOR031W")), ]  # 0 rows
```
</details>
<br />

"YER109C", "YFL057C", "YFL056C", and "YOR031W" are on, respectively, chromosomes V, VI, VI, and XV; "R0010W", "R0020C", "R0030W", and "R0040C" are on "2-micron". Thus, "YER109C", "YFL057C", "YFL056C", and "YOR031W" are apparently valid genes that we *may* care about that are not&mdash;for some reason&mdash;associated with IDs in the Ensembl annotation.

"YER109C", "YFL057C", "YFL056C", and "YOR031W" are not associated with `protein_ID` assignments in `gff3_Ens`; however, in `gff3_Ens`, "YFL056C" appears to be associated with `type` "pseudogene" and "pseudogene_transcript", `biotype` "pseudogene", and corresponding `gene_id` and `transcript_id` entries; the other genes&mdash;"YER109C", "YFL057C", and "YOR031W"&mdash;are not.

"YFL056C" is associated with three rows in `gff3_Ens`: `type`s "pseudogene", "pseudogenic_transcript", and "exon".

"YFL057C" is associated with the "YFL056C" `type` "pseudogene" row (it's in the `description` column)

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
#  repeat region --------------------------------------------------------------
z_gff3_SGD_repeat_region <- gff3_SGD %>%
    dplyr::filter(type == "repeat_region")

z_rr_y_NA <- z_gff3_SGD_repeat_region[is.na(z_gff3_SGD_repeat_region$ID), ]
z_rr_n_NA <- z_gff3_SGD_repeat_region[!is.na(z_gff3_SGD_repeat_region$ID), ]

z_rr_y_NA$Parent %>% unlist()
#  [1] "TEL02L-YP"  "TEL04R-YP"  "TEL05L-YP"  "TEL05R-YP"  "TEL06L-YP"  "TEL07R-YP"  "TEL08L-YP"  "TEL08R-YP"  "TEL09L-YP"  "TEL10L-YP"  "TEL12L-YP1" "TEL12L-YP2" "TEL12R-YP2" "TEL12R-YP1"
# [15] "TEL13L-YP"  "TEL14L-YP"  "TEL15R-YP"  "TEL16L-YP"  "TEL16R-YP"

z_rr_n_NA$Parent %>% unlist()
# character(0)


#  telomere -------------------------------------------------------------------
z_gff3_SGD_telomere <- gff3_SGD %>%
    dplyr::filter(type == "telomere")

z_tel_y_NA <- z_gff3_SGD_telomere[is.na(z_gff3_SGD_telomere$ID), ]
z_tel_n_NA <- z_gff3_SGD_telomere[!is.na(z_gff3_SGD_telomere$ID), ]

table(z_tel_n_NA$end %in% z_rr_n_NA$end)
# TRUE
#   32

table(z_tel_n_NA$start %in% z_rr_n_NA$start)
# TRUE
#   32

gr_tel_n_NA <- GenomicRanges::GRanges(z_tel_n_NA)
gr_rr_n_NA <- GenomicRanges::GRanges(z_rr_n_NA)

IRanges::countOverlaps(gr_tel_n_NA, gr_rr_n_NA)
tmp <- IRanges::findOverlaps(gr_tel_n_NA, gr_rr_n_NA) %>% tibble::as_tibble()
rm(tmp)

IRanges::countOverlaps(gr_rr_n_NA, gr_tel_n_NA)
tmp <- IRanges::findOverlaps(gr_rr_n_NA, gr_tel_n_NA) %>% tibble::as_tibble()
rm(tmp)


#  centromere -----------------------------------------------------------------
z_gff3_SGD_centromere <- gff3_SGD %>%
    dplyr::filter(type == "centromere")

gr_cen <- GenomicRanges::GRanges(z_gff3_SGD_centromere)

IRanges::countOverlaps(gr_cen, gr_tel_n_NA)
IRanges::countOverlaps(gr_cen, gr_rr_n_NA)

# rm(z_rr_n_NA, z_rr_y_NA, z_tel_n_NA, z_tel_y_NA)
# rm(z_gff3_SGD_repeat_region)
# rm(z_gff3_SGD_telomere)
```
</details>
<br />

For `type` "repeat_region", go with `!is.na()`, which encompasses the ranges in `is.na()`.

All of the ranges in `z_rr_n_NA` overlap the ranges in `z_tel_n_NA`. There are no overlaps between `z_gff3_SGD_centromere` and `z_rr_n_NA` (which might be expected), nor are there overlaps between `z_gff3_SGD_centromere` and `z_tel_n_NA` (which are not expected).

`#CONCLUSION` Thus, I think I should exclude `type` "repeat_region" in favor of `type` "telomere". "Centromere" can be included without any problems with any features, I think.

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
z_gff3_SGD_ncRNA <- gff3_SGD %>%
    dplyr::filter(type == "ncRNA")
z_gff3_SGD_noncoding_exon <- gff3_SGD %>%
    dplyr::filter(type == "noncoding_exon")
z_gff3_SGD_tRNA <- gff3_SGD %>%
    dplyr::filter(type == "tRNA")
z_gff3_SGD_snRNA_snoRNA <- gff3_SGD %>%
    dplyr::filter(type == "snRNA" | type == "snoRNA")
z_gff3_SGD_rRNA <- gff3_SGD %>%
    dplyr::filter(type == "rRNA")

z_gff3_noncoding_etc <- gff3_SGD %>%
    dplyr::filter(
        type == "ncRNA" |
        type == "noncoding_exon" |
        type == "tRNA" |
        type == "snoRNA" |
        type == "snRNA" |
        type == "rRNA"
    )

gr_noncoding_exon <- GenomicRanges::GRanges(z_gff3_SGD_noncoding_exon)
gr_noncoding_ncRNA <- GenomicRanges::GRanges(z_gff3_SGD_ncRNA)
gr_tRNA <- GenomicRanges::GRanges(z_gff3_SGD_tRNA)
gr_snRNA_snoRNA <- GenomicRanges::GRanges(z_gff3_SGD_snRNA_snoRNA)
gr_rRNA <- GenomicRanges::GRanges(z_gff3_SGD_rRNA)

sum_1 <- IRanges::countOverlaps(gr_noncoding_exon, gr_noncoding_ncRNA) %>% sum()
tmp_1 <- IRanges::findOverlaps(gr_noncoding_exon, gr_noncoding_ncRNA) %>%
    tibble::as_tibble()

sum_2 <- IRanges::countOverlaps(gr_noncoding_exon, gr_tRNA) %>% sum()
tmp_2 <- IRanges::findOverlaps(gr_noncoding_exon, gr_tRNA) %>%
    tibble::as_tibble()

sum_3 <- IRanges::countOverlaps(gr_noncoding_exon, gr_snRNA_snoRNA) %>% sum()
tmp_3 <- IRanges::findOverlaps(gr_noncoding_exon, gr_snRNA_snoRNA) %>%
    tibble::as_tibble()

sum_4 <- IRanges::countOverlaps(gr_noncoding_exon, gr_rRNA) %>% sum()
tmp_4 <- IRanges::findOverlaps(gr_noncoding_exon, gr_rRNA) %>%
    tibble::as_tibble()

z_gff3_SGD_noncoding_exon[
    z_gff3_SGD_noncoding_exon$Name %notin%
        z_gff3_SGD_noncoding_exon[c(tmp_1$queryHits, tmp_2$queryHits, tmp_3$queryHits), ]$Name, 
]

nrow(z_gff3_SGD_noncoding_exon) - (sum_1 + sum_2 + sum_3)

z_gff3_SGD_noncoding_exon[tmp_1$queryHits, ]
z_gff3_SGD_noncoding_exon[tmp_2$queryHits, ]
z_gff3_SGD_noncoding_exon[tmp_3$queryHits, ]
z_gff3_SGD_noncoding_exon[tmp_4$queryHits, ]

rm(
    z_gff3_SGD_ncRNA, z_gff3_SGD_noncoding_exon, z_gff3_SGD_tRNA,
    z_gff3_SGD_snRNA_snoRNA, z_gff3_SGD_rRNA
)
```
</details>
<br />

`#CONCLUSION` We can exclude `type` "noncoding exon"&mdash;these will be included in "ncRNA", "tRNA", "snoRNA", "snRNA", "rRNA". I think they will not be included with anything else.
`#CONCLUSION` So, here's what to include (so far) for `type`:
- "centromere"
- "genes" (`#MAYBE` stratified by `orf_classification`)
- "ncRNA"
- "rRNA"
- "snRNA"
- "snoRNA"
- "telomere"
- "tRNA"

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
convert_character_0_NA <- function(x) {
    z <- lapply(
        x, function(y) if(identical(y, character(0))) NA_character_ else y
    ) %>%
        unlist()
    
    return(z)
}


flatten_elements_to_one <- function(x) {
    # For character list elements with two or more subelements, collapse the
    # subelements into a single character element
    # 
    # :param x: list
    # :return: character vector of collapsed list elements (list e)
    
    l_collapsed <- x[lengths(x) >= 2] %>% length()
    collapsed <- vector(mode = "character", length = l_collapsed)
    for(i in 1:l_collapsed) {
        # i <- 1
        # cat(i, "\n")
        # cat(x[lengths(x) >= 2][[i]], "\n")
        collapsed[i] <- stringr::str_c(
            x[lengths(x) >= 2][[i]],
            collapse = ", "
        )
    }
    
    return(collapsed)
}


process_list_column <- function(x) {
    x[lengths(x) == 0] <- NA_character_
    if(length(x[lengths(x) >= 2]) != 0) {
        x[lengths(x) >= 2] <- x[lengths(x) >= 2] %>% flatten_elements_to_one()
    }
    y <- x %>% unlist()
    return(y)
}


#  Load tibbles for features ----------
z_gff3_SGD_ARS <- gff3_SGD %>%
    dplyr::filter(type == "ARS")
z_gff3_SGD_LTR <- gff3_SGD %>%
    dplyr::filter(type == "long_terminal_repeat")
z_gff3_SGD_LTR_retrotransposon <- gff3_SGD %>%
    dplyr::filter(type == "LTR_retrotransposon")
z_gff3_SGD_TE_gene <- gff3_SGD %>%
    dplyr::filter(type == "transposable_element_gene")


#  Unlist column Note -----------------
z_gff3_SGD_ARS$Note <- unlist(z_gff3_SGD_ARS$Note)
z_gff3_SGD_LTR$Note <- unlist(z_gff3_SGD_LTR$Note)
z_gff3_SGD_LTR_retrotransposon$Note <- unlist(z_gff3_SGD_LTR_retrotransposon$Note)
z_gff3_SGD_TE_gene$Note <- unlist(z_gff3_SGD_TE_gene$Note)


#  Unlist column Parent ---------------
z_gff3_SGD_ARS$Parent <- convert_character_0_NA(z_gff3_SGD_ARS$Parent)
z_gff3_SGD_LTR$Parent <- convert_character_0_NA(z_gff3_SGD_LTR$Parent)
z_gff3_SGD_LTR_retrotransposon$Parent <- convert_character_0_NA(z_gff3_SGD_LTR_retrotransposon$Parent)
z_gff3_SGD_TE_gene$Parent <- convert_character_0_NA(z_gff3_SGD_TE_gene$Parent)


#  Unlist column Alias ----------------
z_gff3_SGD_ARS$Alias <- process_list_column(z_gff3_SGD_ARS$Alias)
z_gff3_SGD_LTR$Alias <- process_list_column(z_gff3_SGD_LTR$Alias)
z_gff3_SGD_LTR_retrotransposon$Alias <- process_list_column(z_gff3_SGD_LTR_retrotransposon$Alias)
z_gff3_SGD_TE_gene$Alias <- process_list_column(z_gff3_SGD_TE_gene$Alias)


#  Unlist column Ontology_term --------
z_gff3_SGD_ARS$Ontology_term <- process_list_column(z_gff3_SGD_ARS$Ontology_term)
z_gff3_SGD_LTR$Ontology_term <- process_list_column(z_gff3_SGD_LTR$Ontology_term)
z_gff3_SGD_LTR_retrotransposon$Ontology_term <- process_list_column(z_gff3_SGD_LTR_retrotransposon$Ontology_term)
z_gff3_SGD_TE_gene$Ontology_term <- process_list_column(z_gff3_SGD_TE_gene$Ontology_term)


#  Check tibbles ----------------------
z_gff3_SGD_ARS
z_gff3_SGD_LTR
z_gff3_SGD_LTR_retrotransposon
z_gff3_SGD_TE_gene

z_gff3_SGD_ARS %>%
    dplyr::group_by(Note) %>%
    dplyr::summarize(n = dplyr::n())

z_gff3_SGD_LTR %>%
    dplyr::group_by(Note) %>%
    dplyr::summarize(n = dplyr::n())

z_gff3_SGD_LTR_retrotransposon %>%
    dplyr::group_by(Note) %>%
    dplyr::summarize(n = dplyr::n())

z_gff3_SGD_TE_gene %>%
    dplyr::group_by(Note) %>%
    dplyr::summarize(n = dplyr::n())


#  ------
gr_ARS <- GenomicRanges::GRanges(z_gff3_SGD_ARS)
gr_LTR <- GenomicRanges::GRanges(z_gff3_SGD_LTR)
gr_LTR_retrotransposon <- GenomicRanges::GRanges(z_gff3_SGD_LTR_retrotransposon)
gr_TE_gene <- GenomicRanges::GRanges(z_gff3_SGD_TE_gene)

#  1 ----
z_gff3_SGD_LTR %>% dplyr::arrange(seqnames, start)
z_gff3_SGD_LTR_retrotransposon %>% dplyr::arrange(seqnames, start)

sum_1 <- IRanges::countOverlaps(gr_LTR, gr_LTR_retrotransposon) %>% sum()
tmp_1 <- IRanges::findOverlaps(gr_LTR, gr_LTR_retrotransposon) %>%
    tibble::as_tibble()

z_gff3_SGD_LTR[tmp_1$queryHits, ]
z_gff3_SGD_LTR_retrotransposon[tmp_1$subjectHits, ]

z_gff3_SGD_LTR_retrotransposon[seq(1, nrow(z_gff3_SGD_LTR_retrotransposon)) %notin% unique(tmp_1$subjectHits), ]

#  2 -----
z_gff3_SGD_LTR %>% dplyr::arrange(seqnames, start) # %>% nrow()
z_gff3_SGD_TE_gene %>% dplyr::arrange(seqnames, start)

sum_2 <- IRanges::countOverlaps(gr_LTR, gr_TE_gene) %>% sum()
tmp_2 <- IRanges::findOverlaps(gr_LTR, gr_TE_gene) %>%
    tibble::as_tibble()

z_gff3_SGD_LTR[tmp_2$queryHits, ]
z_gff3_SGD_TE_gene[tmp_2$subjectHits, ]

z_gff3_SGD_LTR[seq(1, nrow(z_gff3_SGD_LTR)) %notin% unique(tmp_2$subjectHits), ] %>% nrow()

#  3 -----
z_gff3_SGD_LTR_retrotransposon %>% dplyr::arrange(seqnames, start) # %>% nrow()
z_gff3_SGD_TE_gene %>% dplyr::arrange(seqnames, start) # %>% nrow()

sum_3 <- IRanges::countOverlaps(gr_LTR_retrotransposon, gr_TE_gene) %>% sum()
tmp_3 <- IRanges::findOverlaps(gr_LTR_retrotransposon, gr_TE_gene) %>%
    tibble::as_tibble()

z_gff3_SGD_LTR_retrotransposon[tmp_3$queryHits, ]
z_gff3_SGD_TE_gene[tmp_3$subjectHits, ]

z_gff3_SGD_LTR_retrotransposon[seq(1, nrow(z_gff3_SGD_LTR_retrotransposon)) %notin% unique(tmp_3$subjectHits), ]

#  4 -----
z_gff3_SGD_LTR
z_gff3_SGD_ARS

sum_4 <- IRanges::countOverlaps(gr_LTR, gr_ARS) %>% sum()
tmp_4 <- IRanges::findOverlaps(gr_LTR, gr_ARS) %>%
    tibble::as_tibble()

z_gff3_SGD_LTR[tmp_4$queryHits, ]
z_gff3_SGD_ARS[tmp_4$subjectHits, ]

z_gff3_SGD_LTR[seq(1, nrow(z_gff3_SGD_LTR)) %notin% unique(tmp_4$subjectHits), ]

#  ------
z_gff3_SGD_LTR[tmp_4$queryHits, ]
z_gff3_SGD_ARS[tmp_4$subjectHits, ]
z_gff3_SGD_LTR[seq(1, nrow(z_gff3_SGD_LTR)) %notin% tmp_4$queryHits, ]
z_gff3_SGD_ARS[seq(1, nrow(z_gff3_SGD_ARS)) %notin% tmp_4$subjectHits, ]
```
</details>
<br />

Almost all `z_gff3_SGD_LTR_retrotransposon` overlaps `z_gff3_SGD_LTR`&mdash;all except IV 878303 884220	5918 - SGD LTR_retrotransposon ... YDRCTy1-2 SGD:S000006860 YDRCTy1-2 ...

82 out of 89 TEs (`z_gff3_SGD_TE_gene`) at least partially overlap 301 out of 383 LTRs (`z_gff3_SGD_LTR`)

All 89 TEs (`z_gff3_SGD_TE_gene`) at least partially overlap all but one row in `z_gff3_SGD_LTR_retrotransposon`

20 LTRs overlap ARSs

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
gff3_mystery <- gff3_SGD %>%
    dplyr::filter(
        type == "nucleotide_match" |
        type == "binding_site" |
        type == "region" |
        type == "five_prime_UTR_intron" |
        type == "gene_cassette" |
        type == "insertion" |
        type == "external_transcribed_spacer_region" |
        type == "internal_transcribed_spacer_region"
    )


#  Unlist column Note
gff3_mystery$Note <- process_list_column(gff3_mystery$Note)

#  Unlist column Parent
gff3_mystery$Parent <- process_list_column(gff3_mystery$Parent)

#  Unlist column Alias
gff3_mystery$Alias <- process_list_column(gff3_mystery$Alias)

#  Unlist column Ontology_term
gff3_mystery$Ontology_term <- process_list_column(gff3_mystery$Ontology_term)


gff3_SGD %>% dplyr::filter(dbxref == "SGD:S000029655")
gff3_SGD %>% dplyr::filter(ID == "HMR")
gff3_SGD %>% dplyr::filter(Name == "YJR027W")
gff3_SGD %>% dplyr::filter(Name == "YBL092W")

# gff3_SGD %>% dplyr::filter(type == "intron")  # Yeah, let's exclude introns, which will be included along with gene or tRNA (or etc.) entries
```
</details>
<br />

We can exclude `type` "nucleotide_match", which mostly seem to be parts of telomere and ARS features

We can exclude `type` "binding_site", which are all within telomere features

We can also exclude `type` "region", which seem to be encompassed in other features

Retain `type` "five_prime_UTR_intron"

~~Retain `type` "gene_cassette"~~ After discussion with Toshi, we realize that these features will be encompassed by other features (e.g., within `type` "gene"), so we can exclude `type` "gene_cassette"

~~Retain `type` "external_transcribed_spacer_region" and "internal_transcribed_spacer_region"~~ Actually, don't b/c these are already covered by `type` "rRNA"


## Survey all of the notes I have taken so far and make decisions
Go with the SGD annotation for this work.

We should not remove any entries from `type` "gene" despite there being an extra four chromosomal genes in the SGD annotation versus the Ensembl R64-1-1 annotation.

We should exclude `type` "repeat_region" in favor of `type` "telomere". "Centromere" can be included without any problems with any features.

We can exclude `type` "noncoding exon" since these will be included in variously "ncRNA", "tRNA", "snoRNA", "snRNA", "rRNA".

`#DEKHO` `#IMPORTANT`
So, here's what to include for `type`:
- "ARS" (both strands)
- "centromere" (both strands)
- "gene" (antisense too)
- "ncRNA" (antisense too)
- "pseudogene" (those that are not collapsed/merged into "transposable_element" below; antisense too)
- "rRNA" (antisense too)
- "snRNA" (antisense too)
- "snoRNA" (antisense too)
- "telomere" (both strands)
- "transposable_element" (made from collapsing/merging "long_terminal_repeat", "LTR_retrotransposon", "transposable_element_gene" and "pseudogene"; antisense too)
- "tRNA" (antisense too)


And here's what not to include for `type`:
- "binding_site"
- "CDS"
- "chromosome"
- "external_transcribed_spacer_region" (already in `type` "rRNA")
- "five_prime_UTR_intron" (already in `type` "gene" and `type` intergenic)
- "gene_cassette" (already in `type` "gene" and `type` "intergenic")
- "insertion"
- "internal_transcribed_spacer_region" (already in `type` "rRNA")
- "intron"
- "noncoding_exon"
- "nucleotide_match"
- "region"
- "repeat_region"

```{r}
# stackoverflow.com/questions/6190051/how-can-i-remove-all-objects-but-one-from-the-workspace-in-r
rm(list = setdiff(ls(), "gff3_SGD"))


#  Initialize functions -------------------------------------------------------
# `%+=%` <- function(x, y) eval.parent(substitute(x <- x + y))
# # stackoverflow.com/questions/5738831/r-plus-equals-and-plus-plus-equivalent-from-c-c-java-etc


# detect_overlap <- function(x, y) {
#     # Detect overlaps
#     # :param x: row number <numeric>
#     # :param y: range start and end columns/vectors <numeric>
#     # :return z: Boolean <0 or 1>
#     z <- ifelse(x[2] >= y[1], 1, 0)
#     return(z)
# }


# nonOverlappingGR <- function(
#     #' Retrieve a non-overlapping set of regions from a `GenomicRanges` object
#     #' 
#     #' This function returns a `GRanges` object containing a non-overlapping set 
#     #' regions derived from a supplied `GenomicRanges` object. Taken from
#     #' github.com/GreenleafLab/ArchR/blob/master/R/GRangesUtils.R#L60
#     #'
#     #' @param gr A `GRanges` object.
#     #' @param by The name of a column in `mcols(gr)` that should be used to
#     #' determine how overlapping regions should be resolved.
#     #' The resolution of overlapping regions also depends on `decreasing`. For
#     #' example, if a column named "score" is used for `by`, `decreasing = TRUE`
#     #' means that the highest "score" in the overlap will be retained and
#     #' `decreasing = FALSE` means that the lowest "score" in the overlap will
#     #' be retained.
#     #' @param decreasing A boolean value indicating whether the values in the
#     #' column indicated via `by` should be ordered in decreasing order. If
#     #' `TRUE`, the higher value in `by` will be retained.
#     #' @param verbose A boolean value indicating whether the output should
#     #' include extra reporting.
#     #' @export
# 	gr = NULL, 
# 	by = "score", 
# 	decreasing = TRUE, 
# 	verbose = FALSE
#   ){
#     # .validInput(input = gr, name = "gr", valid = c("GRanges"))
#     # .validInput(input = by, name = "by", valid = c("character"))
#     # .validInput(input = decreasing, name = "decreasing", valid = c("boolean"))
#     # .validInput(input = verbose, name = "verbose", valid = c("boolean"))
#     
#     stopifnot(by %in% colnames(mcols(gr)))
#     
#     #  Cluster GRanges into islands using reduce and then select based on input
#     .clusterGRanges <- function(
#         gr = NULL,
#         filter = TRUE,
#         by = "score",
#         decreasing = TRUE
#     ){
#         gr <- sort(sortSeqlevels(gr))
#         r <- GenomicRanges::reduce(gr, min.gapwidth = 0L, ignore.strand = TRUE)
#         o <- findOverlaps(gr, r, ignore.strand = TRUE)
#         mcols(gr)$cluster <- subjectHits(o)
#         gr <- gr[order(mcols(gr)[, by], decreasing = decreasing), ]
#         gr <- gr[!duplicated(mcols(gr)$cluster), ]
#         gr <- sort(sortSeqlevels(gr))
#         mcols(gr)$cluster <- NULL
#         return(gr)
#     }
#     
#     if(verbose) message("Converging", appendLF = FALSE)
#     
#     i <-  0
#     grConverge <- gr
#     while(length(grConverge) > 0) {
#         if(verbose){
#             message(".", appendLF = FALSE)
#         }
#         i <-  i + 1
#         grSelect <- .clusterGRanges(
#             gr = grConverge, 
#             filter = TRUE, 
#             by = by, 
#             decreasing = decreasing
#         )
#         
#         grConverge <- subsetByOverlaps(
#             grConverge,
#             grSelect, 
#             invert=TRUE, 
#             ignore.strand = TRUE
#         )  # Blacklist selected gr
#         
#         if(i == 1){  # If i is 1, then set gr_all to clustered
#             grAll <- grSelect
#         } else {
#             grAll <- c(grAll, grSelect)
#         } 
#     
#     }
#     message(sprintf("Converged after %s iterations!", i))
#     
#     if(verbose) {
#         message("\nSelected ", length(grAll), " from ", length(gr))
#     }
#     grAll <- sort(sortSeqlevels(grAll))
#     
#     return(grAll)
# }


flatten_elements_to_one <- function(x) {
    # For character list elements with two or more subelements, collapse the
    # subelements into a single character element
    # 
    # :param x: list
    # :return: character vector of collapsed list elements (list e)
    
    l_collapsed <- x[lengths(x) >= 2] %>% length()
    collapsed <- vector(mode = "character", length = l_collapsed)
    for(i in 1:l_collapsed) {
        collapsed[i] <- stringr::str_c(
            x[lengths(x) >= 2][[i]],
            collapse = ", "
        )
    }
    
    return(collapsed)
}


process_list_column <- function(x) {
    x[lengths(x) == 0] <- NA_character_
    if(length(x[lengths(x) >= 2]) != 0) {
        x[lengths(x) >= 2] <- x[lengths(x) >= 2] %>% flatten_elements_to_one()
    }
    y <- x %>% unlist()

    return(y)
}


write_gtf <- function(x, y) {
    # ...
    # :param x: tibble
    # :param y: outfile
    # :return: NA
    readr::write_tsv(
        x,
        y,
        col_names = FALSE,
        quote = "none",
        escape = "none"
    )
}


format_SGD_tibble <- function(x) {
    # ...
    # :param x: tibble
    # :return y: tibble in a basic gtf/gff2 format
    y <- x %>%
        dplyr::arrange(seqnames, start) %>%
        dplyr::rename(seqname =  seqnames) %>%
        dplyr::filter(seqname != "2-micron") %>%
        dplyr::mutate(feature = "feature", score = ".", frame = ".") %>%
        dplyr::relocate(c(source, feature), .after = seqname) %>%
        dplyr::relocate(c(score, strand, frame), .after = end) %>%
        dplyr::mutate(
            attribute = paste(
                paste0("gene_id \"", ID, "\""),
                paste0("transcript_id \"", ID, "\""),
                paste0("type \"", type, "\""),
                paste0("orf_classification \"", orf_classification, "\""),
                paste0("source_id \"", gsub("SGD:", "", dbxref), "\""),
                sep = "; "
            )
        ) %>%
        dplyr::select(-c(
            Alias, dbxref, gene, ID, Name, Note, Ontology_term,
            orf_classification, type, width
        ))
    
    return(y)
}


#  Isolate the features that we (may) want to obtain antisense counts ---------
features_etc <- gff3_SGD %>%
    dplyr::filter(
        type == "gene" |
        type == "ncRNA" |
        type == "rRNA" |
        type == "snRNA" |
        type == "snoRNA" |
        type == "tRNA"
    ) %>%
    dplyr::filter(
        seqnames != "2-micron" &
        seqnames != "Mito"
    ) %>%
    dplyr::select(-c(Parent, phase, score)) %>%
    dplyr::arrange(seqnames, start, strand)
features_etc$Note <- process_list_column(features_etc$Note)
features_etc$Alias <- process_list_column(features_etc$Alias)
features_etc$Ontology_term <- process_list_column(features_etc$Ontology_term)
features_etc$ID <- features_etc$Name <- ifelse(
    features_etc$type == "five_prime_UTR_intron",
    paste0(features_etc$Name, "_5p"),
    ifelse(
        features_etc$type == "repeat_region",
        paste(
            features_etc$Name,
            paste0(
                features_etc$seqnames, ":",
                features_etc$start, "-",
                features_etc$end
            ),
            sep = "_"
        ),
        features_etc$Name
    )
)

# duplicated(features_etc$Name) %>% table()
# duplicated(features_etc$ID) %>% table()

# features_etc %>%
#     dplyr::group_by(type) %>%
#     dplyr::summarize(n = dplyr::n()) %>%
#     dplyr::arrange(dplyr::desc(n))

# all(features_etc$ID == features_etc$Name)


#  Create a dataframe of features antisense to features in features_etc -------
features_etc_antisense <- features_etc
features_etc_antisense$strand <- ifelse(
    features_etc_antisense$strand == "+", "-", "+"
)
features_etc_antisense$source <- "SGD (KA)"
features_etc_antisense$type <- paste(
    "antisense", features_etc_antisense$type, sep = "_"
)
features_etc_antisense$ID <-
    features_etc_antisense$Name <-
    paste("AS", features_etc_antisense$Name, sep = "_")

# features_etc_antisense %>%
#     dplyr::group_by(strand) %>%
#     dplyr::summarize(n = dplyr::n())


#  Collapse and merge transposable-element and related features ---------------
TE_PG <- gff3_SGD %>% dplyr::filter(        
    type == "long_terminal_repeat" |
    type == "LTR_retrotransposon" |
    type == "transposable_element_gene" |
    type == "pseudogene"
) %>%
    dplyr::filter(
        seqnames != "2-micron" &
        seqnames != "Mito"
    ) %>%
    dplyr::select(-c(score, phase, Parent)) %>%
    dplyr::arrange(seqnames, start, strand)
TE_PG$Note <- process_list_column(TE_PG$Note)
TE_PG$Alias <- process_list_column(TE_PG$Alias)
TE_PG$Ontology_term <- process_list_column(TE_PG$Ontology_term)
TE_PG$ID <- TE_PG$Name <- ifelse(
    TE_PG$type == "five_prime_UTR_intron",
    paste0(TE_PG$Name, "_5p"),
    ifelse(
        TE_PG$type == "repeat_region",
        paste(
            TE_PG$Name,
            paste0(
                TE_PG$seqnames, ":",
                TE_PG$start, "-",
                TE_PG$end
            ),
            sep = "_"
        ),
        TE_PG$Name
    )
)

#  If they overlap, and after stratifying for 'chr' and 'strand', then organize
#+ rows into groups  
TE_PG_group_chr_strand <- plyr::ddply(
    TE_PG,
    c("seqnames", "strand"),
    function(x) { 
        #  Check if a record should be linked with the previous record
        y <- c(NA, x$end[-nrow(x)])
        z <- ifelse(is.na(y), 0, y)
        z <- cummax(z)
        z[is.na(y)] <- NA
        x$previous_end <- z
        
        return(x)
    }
)
TE_PG_group_chr_strand$new_group <- is.na(TE_PG_group_chr_strand$previous_end) | 
    (TE_PG_group_chr_strand$start >= TE_PG_group_chr_strand$previous_end)
TE_PG_group_chr_strand$group <- cumsum(TE_PG_group_chr_strand$new_group)
TE_PG_group_chr_strand <- TE_PG_group_chr_strand %>%
    dplyr::mutate(type_ID = paste0(type, ": ", ID))

#  Aggregate the data
TE_PG_agg_chr_strand <- plyr::ddply(
    TE_PG_group_chr_strand,
    .(seqnames, strand, group),
    plyr::summarize, 
    start = min(start),
    end = max(end),
    width = (end - start) + 1,
    ID = paste0(ID, collapse = "; "),
    dbxref = paste0(dbxref, collapse = "; "),
    Name = paste0(type_ID, collapse = "; "),
    Note = paste0(Note, collapse = "; "),
    Ontology_term = paste0(Ontology_term, collapse = "; "),
    Alias = paste0(type, collapse = "; ")
) %>%
    dplyr::mutate(
        strand = strand,
        source = "SGD (KA)",
        type = ifelse(
            Alias == "pseudogene" | Alias == "pseudogene; pseudogene",
            "PG",
            "TE"
        ),
        orf_classification = NA_character_,
        gene = NA_character_
    ) %>%
    dplyr::select(-group) %>% 
    dplyr::arrange(seqnames, start, strand) %>%
    dplyr::relocate(c(
        seqnames, start, end, width, strand, source, type, ID, dbxref, Name,
        Note, Ontology_term, orf_classification, Alias, gene
    ))

details_Alias <- TE_PG_agg_chr_strand$Alias %>%
    stringr::str_remove_all("s") %>%
    stringr::str_split("; ") %>%
    purrr::map(sort) %>%
    purrr::map(unique)
details_Alias <- sapply(
    details_Alias[!sapply(details_Alias, purrr::is_empty)],
    paste,
    collapse = " "
) %>%
    gsub("long_terminal_repeat", "LTR", .) %>%
    gsub("LTR_retrotranpoon", "RT", .) %>%
    gsub("tranpoable_element_gene", "TE", .) %>%
    gsub("peudogene", "PG", .)

details_Name <- TE_PG_agg_chr_strand$Name %>%
    stringr::str_remove_all("s") %>%
    stringr::str_split("; ") %>%
    purrr::map(sort) %>%
    purrr::map(unique)
details_Name <- sapply(
    details_Name[!sapply(details_Name, purrr::is_empty)],
    paste,
    collapse = "; "
) %>%
    gsub("long_terminal_repeat", "LTR", .) %>%
    gsub("LTR_retrotranpoon", "RT", .) %>%
    gsub("tranpoable_element_gene", "TE_gene", .) %>%
    gsub("peudogene", "PG", .)

TE_PG_agg_chr_strand$Name <- details_Name
TE_PG_agg_chr_strand$Alias <- details_Alias
TE_PG_agg_chr_strand$n_types <- ifelse(
    grepl(" ", TE_PG_agg_chr_strand$Alias, fixed = TRUE),
    stringr::str_count(TE_PG_agg_chr_strand$Alias, " ") + 1,
    1
)
TE_PG_agg_chr_strand$n_features <- ifelse(
    grepl(";", TE_PG_agg_chr_strand$ID, fixed = TRUE),
    stringr::str_count(TE_PG_agg_chr_strand$ID, ";") + 1,
    1
)

TE_PG <- TE_PG_agg_chr_strand
TE_PG$ID <- gsub("; ", "_", TE_PG$ID)
TE_PG$Ontology_term <- TE_PG$Ontology_term %>%
    gsub("; ", "_", .) %>%
    gsub(", ", "-", .)
TE_PG$Name <- TE_PG$Name %>%
    gsub(": ", "-", .) %>%
    gsub("; ", "_", .) %>%
    gsub("TE_gene", "TE", .)
# TE_PG %>%
#     dplyr::group_by(strand) %>%
#     dplyr::summarize(n = dplyr::n())

rm(TE_PG_agg_chr_strand, TE_PG_group_chr_strand, details_Alias, details_Name)


#  Create a dataframe of TE features antisense to features in features_etc ----
TE_PG_antisense <- TE_PG
TE_PG_antisense$strand <- ifelse(TE_PG_antisense$strand == "+", "-", "+")
TE_PG_antisense$source <- "SGD (KA)"
TE_PG_antisense$type <- paste("antisense", TE_PG_antisense$type, sep = "_")
TE_PG_antisense$ID <- paste("AS", TE_PG_antisense$ID, sep = "_")
TE_PG_antisense$Name <- paste("AS", TE_PG_antisense$Name, sep = "_")

# TE_PG_antisense %>%
#     dplyr::group_by(strand) %>%
#     dplyr::summarize(n = dplyr::n())


#  Make ARS, telomere, and centromere entries for plus and minus strands ------
ARS_etc_plus <- gff3_SGD %>%
    dplyr::filter(
        type == "ARS" | type == "telomere" | type == "centromere"
    ) %>%
    dplyr::select(-c(Parent, phase, score))
ARS_etc_plus$Note <- process_list_column(ARS_etc_plus$Note)
ARS_etc_plus$Alias <- process_list_column(ARS_etc_plus$Alias)
ARS_etc_plus$Ontology_term <- process_list_column(ARS_etc_plus$Ontology_term)
ARS_etc_plus$Name <- ifelse(
    ARS_etc_plus$type == "five_prime_UTR_intron",
    paste0(ARS_etc_plus$Name, "_5p"),
    ifelse(
        ARS_etc_plus$type == "repeat_region",
        paste(
            ARS_etc_plus$Name,
            paste0(
                ARS_etc_plus$seqnames, ":",
                ARS_etc_plus$start, "-", ARS_etc_plus$end
            ),
            sep = "_"
        ),
        ARS_etc_plus$Name
    )
)
ARS_etc_plus$ID <- ARS_etc_plus$Name

ARS_etc_minus <- ARS_etc_plus
ARS_etc_plus$strand <- "+"
ARS_etc_minus$strand <- "-"
ARS_etc_plus$ID <-
    ARS_etc_plus$Name <-
    paste("plus", ARS_etc_plus$Name, sep = "_")
ARS_etc_minus$ID <-
    ARS_etc_minus$Name <-
    paste("minus", ARS_etc_minus$Name, sep = "_")


#  Load dataframe of intergenic annotations -----------------------------------
p_tsv <- "infiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203"
f_tsv <- "NotFeature_R64-1-1_20110203.dataframe.tsv"
intergenic_plus <- readr::read_tsv(
    paste(p_tsv, f_tsv, sep = "/"),
    show_col_types = FALSE
) %>%
    dplyr::select(-"...1")
rm(p_tsv, f_tsv)

chr_roman <- sapply(
    intergenic_plus$chr,
    function(x) {
        as.character(
            if(grepl("^2-micron$", x)) "2-micron"
            else if(grepl("^Mito$", x)) "Mito"
            else if(grepl("^[1-9]\\d*$", x)) as.roman(x)
        )
    }
)
# chr_roman %>%
#     as_tibble() %>%
#     group_by(value) %>%
#     summarize(n = n())

intergenic_plus$chr <- chr_roman
rm(chr_roman)

# intergenic_plus %>%
#     dplyr::group_by(chr) %>%
#     dplyr::summarize(n = dplyr::n()) %>%
#     dplyr::arrange(chr)

#  Format the dataframe for binding with dataframes of other features
intergenic_plus <- intergenic_plus %>%    
    dplyr::mutate(
        seqnames = chr,
        width = (end - start) + 1,
        source = "SGD (KA)",
        type = "intergenic",
        ID = feature,
        dbxref = NA_character_,
        Name = feature,
        Ontology_term = NA_character_,
        orf_classification = NA_character_,
        Alias = coord_pre_n,
        gene = NA_character_
    ) %>%
    dplyr::rename(Note = notes) %>%
    dplyr::select(-c(
        chr, strand_written, category, feature, coord_written, coord_pre_y,
        coord_pre_n, chr_pre_y
    )) %>%
    dplyr::relocate(c(
        seqnames, start, end, width, strand, source, type, ID, dbxref, Name,
        Note, Ontology_term, orf_classification, Alias, gene
    ))

#  Add a dataframe for minus-strand intergenic frames; then, continue to format
#+ the plus- and minus-strand dataframes
intergenic_minus <- intergenic_plus
intergenic_minus$strand <- "-"
intergenic_minus$ID <- paste("minus", intergenic_minus$ID, sep = "_")
intergenic_plus$ID <- paste("plus", intergenic_plus$ID, sep = "_")
intergenic_minus$Name <- paste("minus", intergenic_minus$Name, sep = "_")
intergenic_plus$Name <- paste("plus", intergenic_plus$Name, sep = "_")
intergenic_minus$Alias <- paste("minus", intergenic_minus$Alias, sep = "_")
intergenic_plus$Alias <- paste("plus", intergenic_plus$Alias, sep = "_")
intergenic_minus$Note <- intergenic_minus$Note %>% gsub("between", "Between", .)
intergenic_plus$Note <- intergenic_plus$Note %>% gsub("between", "Between", .)

#+ Row-bind the plus- and minus-strand dataframes
intergenic <- dplyr::bind_rows(intergenic_plus, intergenic_minus) %>%
    dplyr::arrange(seqnames, start, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")

rm(intergenic_minus, intergenic_plus)


#  Row-bind dataframes --------------------------------------------------------
#  S features/TE_PG with dual-strand ARS, telomeres, and centromeres
#+ 6972 + 348 + (385*2)
z_sense <- dplyr::bind_rows(
    features_etc,
    dplyr::select(TE_PG, -c(n_types, n_features)),
    ARS_etc_plus,
    ARS_etc_minus
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")

#  S and AS features/TE_PG with dual-strand ARS, telomeres, and centromeres
#+ (6972 + 348)*2 + (385*2)
z_sense_antisense <- dplyr::bind_rows(
    features_etc,
    features_etc_antisense,
    dplyr::select(TE_PG, -c(n_types, n_features)),
    dplyr::select(TE_PG_antisense, -c(n_types, n_features)),
    ARS_etc_plus,
    ARS_etc_minus
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")

#  AS features/TE_PG with dual-strand ARS, telomeres, and centromeres
#+ 6972 + 348 + (385*2)
z_antisense <- dplyr::bind_rows(
    features_etc_antisense,
    dplyr::select(TE_PG_antisense, -c(n_types, n_features)),
    ARS_etc_plus,
    ARS_etc_minus
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")

#  Row-bind above three dataframes with intergenic-annotation dataframe
z_sense_intergenic <-
    dplyr::bind_rows(z_sense, intergenic) %>%
    dplyr::arrange(seqnames, start, end, strand)

z_sense_antisense_intergenic <-
    dplyr::bind_rows(z_sense_antisense, intergenic) %>%
    dplyr::arrange(seqnames, start, end, strand)

z_antisense_intergenic <-
    dplyr::bind_rows(z_antisense, intergenic) %>%
    dplyr::arrange(seqnames, start, end, strand)


#  Write gtf files ------------------------------------------------------------
#  Set up outdirectory
p_out <- "outfiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203/"

#  Antisense features_etc
z_antisense %>%
    format_SGD_tibble() %>%
    write_gtf(., paste(p_out, "processed_features_antisense.gtf", sep = "/"))

#  Antisense features_etc together with intergenic regions
z_antisense_intergenic %>%
    format_SGD_tibble() %>%
    write_gtf(., paste(p_out, "processed_features-intergenic_antisense.gtf", sep = "/"))

#  Sense features_etc
z_sense %>%
    format_SGD_tibble() %>%
    write_gtf(., paste(p_out, "processed_features_sense.gtf", sep = "/"))

#  Sense and antisense features_etc
z_sense_antisense %>%
    format_SGD_tibble() %>%
    write_gtf(., paste(p_out, "processed_features_sense-antisense.gtf", sep = "/"))

#  Sense and antisense features_etc together with intergenic regions
z_sense_antisense_intergenic %>%
    format_SGD_tibble() %>%
    write_gtf(., paste(p_out, "processed_features-intergenic_sense-antisense.gtf", sep = "/"))

#  Sense features_etc along with intergenic regions
z_sense_intergenic %>%
    format_SGD_tibble() %>%
    write_gtf(., paste(p_out, "processed_features-intergenic_sense.gtf", sep = "/"))

#  Sense TE
z_sense %>%
    dplyr::filter(type == "TE") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_TE_sense.gtf", sep = "/"))

#  Sense PG
z_sense %>%
    dplyr::filter(type == "PG") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_PG_sense.gtf", sep = "/"))

#  Sense ncRNA
z_sense %>%
    dplyr::filter(type == "ncRNA") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_ncRNA_sense.gtf", sep = "/"))

#  Sense gene
z_sense %>%
    dplyr::filter(type == "gene") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_gene_sense.gtf", sep = "/"))

#  Dual-strand ARS
z_sense %>%
    dplyr::filter(type == "ARS") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_ARS_dual-strand.gtf", sep = "/"))

#  Sense tRNA
z_sense %>%
    dplyr::filter(type == "tRNA") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_tRNA_sense.gtf", sep = "/"))

#  Sense snoRNA
z_sense %>%
    dplyr::filter(type == "snoRNA") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_snoRNA_sense.gtf", sep = "/"))

#  Dual-strand telomere
z_sense %>%
    dplyr::filter(type == "telomere") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_telomere_dual-strand.gtf", sep = "/"))

#  Dual-strand centromere
z_sense %>%
    dplyr::filter(type == "centromere") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_centromere_dual-strand.gtf", sep = "/"))

#  Sense rRNA
z_sense %>%
    dplyr::filter(type == "rRNA") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_rRNA_sense.gtf", sep = "/"))

#  Sense snRNA
z_sense %>%
    dplyr::filter(type == "snRNA") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_snRNA_sense.gtf", sep = "/"))

#  Dual-strand intergenic
z_sense_intergenic %>%
    dplyr::filter(type == "intergenic") %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_intergenic_dual-strand.gtf", sep = "/"))

#  Sense RNA species
z_sense %>%
    dplyr::filter(
        type == "tRNA" | 
        type == "snoRNA" | 
        type == "rRNA" | 
        type == "ncRNA" | 
        type == "snRNA"
    ) %>%
    format_SGD_tibble() %>%
    # View()
    write_gtf(., paste(p_out, "processed_RNA-species_sense.gtf", sep = "/"))


#  Scraps ---------------------------------------------------------------------
z_sense_intergenic %>%
    dplyr::group_by(type) %>%
    dplyr::summarize(n = dplyr::n()) %>%
    dplyr::arrange(desc(n)) %>%
    View()

z_sense %>%
    dplyr::filter(type == "gene") %>%
    dplyr::arrange(orf_classification, seqnames, start) %>%
    View()

z_sense %>%
    dplyr::filter(type == "gene") %>%
    dplyr::group_by(orf_classification) %>%
    dplyr::summarize(n = dplyr::n()) %>%
    dplyr::arrange(desc(n)) %>%
    View()

z_sense %>%
    dplyr::filter(type == "gene") %>%
    dplyr::filter(is.na(orf_classification)) %>%
    View()

z_sense_antisense_intergenic %>%
    dplyr::group_by(type) %>%
    dplyr::summarize(n = dplyr::n()) %>%
    dplyr::arrange(desc(n)) %>%
    View()

# all(colnames(test) == colnames(features_etc))  # [1] TRUE
#
# gff3_SGD %>%
#     dplyr::filter(type == "gene") %>%
#     dplyr::group_by(orf_classification) %>%
#     dplyr::summarize(n = dplyr::n())
```

## ...
### ...
```{r}
p_Q <- "outfiles_gtf-gff3/Trinity-GG/Q_N/filtered/locus"
f_Q <- "Q_mkc-4_gte-pctl-25.corrected.gtf"
gtf_Q <- rtracklayer::import(paste(p_Q, f_Q, sep = "/")) %>%
    tibble::as_tibble() %>%
    dplyr::select(-c(Parent, phase, score)) %>%
    dplyr::arrange(seqnames, start, strand)

p_G <- "outfiles_gtf-gff3/Trinity-GG/G_N/filtered/locus"
f_G <- "G1_mkc-4_gte-pctl-25.corrected.gtf"
gtf_G1 <- rtracklayer::import(paste(p_G, f_G, sep = "/")) %>%
    tibble::as_tibble() %>%
    dplyr::select(-c(Parent, phase, score)) %>%
    dplyr::arrange(seqnames, start, strand)

rm(p_Q, f_Q)
rm(p_G, f_G)

gtf_Q$geneIDs <- gtf_Q$geneIDs %>%
    gsub("c\\(", "", .) %>%
    gsub("\\)", "", .) %>%
    gsub("\"", "", .)
gtf_Q$transcripts <- gtf_Q$transcripts %>%
    gsub("c\\(", "", .) %>%
    gsub("\\)", "", .) %>%
    gsub("\"", "", .)

gtf_G1$geneIDs <- gtf_G1$geneIDs %>%
    gsub("c\\(", "", .) %>%
    gsub("\\)", "", .) %>%
    gsub("\"", "", .)
gtf_G1$transcripts <- gtf_G1$transcripts %>%
    gsub("c\\(", "", .) %>%
    gsub("\\)", "", .) %>%
    gsub("\"", "", .)
```

## ...
### ...
```{r}
gtf_all <- z_sense_antisense_intergenic

g_Q <- makeGRangesFromDataFrame(gtf_Q, keep.extra.columns = TRUE)
g_G1 <- makeGRangesFromDataFrame(gtf_G1, keep.extra.columns = TRUE)
g_all <- makeGRangesFromDataFrame(gtf_all, keep.extra.columns = TRUE)

overlap_Q_v_all <- IRanges::findOverlaps(g_Q, g_all)
overlap_G1_v_all <- IRanges::findOverlaps(g_G1, g_all)

gtf_Q[queryHits(overlap_Q_v_all), ]
gtf_all[subjectHits(overlap_Q_v_all), ]

#  Create rows for feature in "Q" overlapping feature in "all"
wrt_Q_all <- dplyr::bind_cols(
    gtf_Q[queryHits(overlap_Q_v_all), ],
    gtf_all[subjectHits(overlap_Q_v_all), ]
) %>%
    dplyr::rename(
        seqnames = seqnames...1,
        start = start...2,
        end = end...3,
        width = width...4,
        strand = strand...5,
        source = source...6,
        type = type...7,
        ID = ID...8,
        seqnames_all = seqnames...11,
        start_all = start...12,
        end_all = end...13,
        width_all = width...14,
        strand_all = strand...15,
        source_all = source...16,
        type_all = type...17,
        ID_all = ID...18,
        dbxref_all = dbxref,
        Name_all = Name,
        Note_all = Note,
        Ontology_term_all = Ontology_term,
        orf_classification_all = orf_classification,
        Alias_all = Alias,
        gene_all = gene
    )

#  If they overlap after stratifying for 'chr' and 'strand', then organize rows
#+ into groups  
wrt_Q_all_group_chr_strand <- plyr::ddply(
    wrt_Q_all,
    c("seqnames", "strand"),
    function(x) { 
        #  Check if a record should be linked with the previous record
        y <- c(NA, x$end[-nrow(x)])
        z <- ifelse(is.na(y), 0, y)
        z <- cummax(z)
        z[is.na(y)] <- NA
        x$previous_end <- z
        
        return(x)
    }
)
wrt_Q_all_group_chr_strand <- wrt_Q_all_group_chr_strand %>%
    dplyr::relocate(c(start_all, end_all), .after = end)
wrt_Q_all_group_chr_strand$new_group <-
    is.na(wrt_Q_all_group_chr_strand$previous_end) | 
        (
            wrt_Q_all_group_chr_strand$start >=
            wrt_Q_all_group_chr_strand$previous_end
        )
wrt_Q_all_group_chr_strand$group <- cumsum(wrt_Q_all_group_chr_strand$new_group)
wrt_Q_all_group_chr_strand <- wrt_Q_all_group_chr_strand %>%
    dplyr::mutate(type_ID_all = paste0(type_all, ": ", ID_all))

#  Calculate percent overlaps between "Q" and "all" features and vice versa
percent_overlap <- function(x_start, x_end, y_start, y_end){
    # x_length <- abs((x_end + 1) - x_start)
    # min_end <- min(c(x_end, (y_end + 1)))  # Smallest end
    
    # x_length <- abs(x_end - x_start)
    # max_start <- max(c(x_start, y_start))  # Largest start
    # min_end <- min(c(x_end, y_end))  # Smallest end
    # overlap <- min_end - max_start
    # overlap <- ifelse(overlap <= 0, 0, overlap)
    # percent_overlap <- ((overlap / x_length) * 100)
    # return(percent_overlap)
    
    x_length <- abs((x_end + 1) - (x_start - 1))
    max_start <- max(c((x_start - 1), (y_start - 1)))  # Largest start
    min_end <- min(c((x_end + 1), (y_end + 1)))  # Smallest end
    overlap <- min_end - max_start
    overlap <- ifelse(overlap <= 0, 0, overlap)
    percent_overlap <- ((overlap / x_length) * 100)
    return(percent_overlap)
}


test <- wrt_Q_all_group_chr_strand
test$pct_Q_over_all <- mapply(
    percent_overlap, test$start, test$end, test$start_all, test$end_all
)
test$pct_all_over_Q <- mapply(
    percent_overlap, test$start_all, test$end_all, test$start, test$end
)
test <- test %>%
    dplyr::relocate(
        c(pct_Q_over_all, pct_all_over_Q, type_ID_all, group), .after = end_all
    )

# test_overlaps <- percent_overlap(
#     test$start, test$end, test$start_all, test$end_all
# )
# test_overlaps %>% table()
# 
# (test$start <= test$end_all) %>% table()
# (test$end >= test$start_all) %>% table()
# test_olap <- (test$start <= test$end_all) & (test$end >= test$start_all)

#  Aggregate the data
wrt_Q_all_agg_chr_strand <- plyr::ddply(
    wrt_Q_all_group_chr_strand,
    .(seqnames, strand, group),
    plyr::summarize, 
    start = min(start),
    end = max(end),
    width = (end - start) + 1,
    ID = paste0(ID, collapse = "; "),
    dbxref = paste0(dbxref, collapse = "; "),
    Name = paste0(type_ID, collapse = "; "),
    Note = paste0(Note, collapse = "; "),
    Ontology_term = paste0(Ontology_term, collapse = "; "),
    Alias = paste0(type, collapse = "; ")
) %>%
    dplyr::mutate(
        strand = strand,
        source = "SGD (KA)",
        type = ifelse(
            Alias == "pseudogene" | Alias == "pseudogene; pseudogene",
            "PG",
            "TE"
        ),
        orf_classification = NA_character_,
        gene = NA_character_
    ) %>%
    dplyr::select(-group) %>% 
    dplyr::arrange(seqnames, start, strand) %>%
    dplyr::relocate(c(
        seqnames, start, end, width, strand, source, type, ID, dbxref, Name,
        Note, Ontology_term, orf_classification, Alias, gene
    ))

details_Alias <- wrt_Q_all_agg_chr_strand$Alias %>%
    stringr::str_remove_all("s") %>%
    stringr::str_split("; ") %>%
    purrr::map(sort) %>%
    purrr::map(unique)
details_Alias <- sapply(
    details_Alias[!sapply(details_Alias, purrr::is_empty)],
    paste,
    collapse = " "
) %>%
    gsub("long_terminal_repeat", "LTR", .) %>%
    gsub("LTR_retrotranpoon", "RT", .) %>%
    gsub("tranpoable_element_gene", "TE", .) %>%
    gsub("peudogene", "PG", .)

details_Name <- wrt_Q_all_agg_chr_strand$Name %>%
    stringr::str_remove_all("s") %>%
    stringr::str_split("; ") %>%
    purrr::map(sort) %>%
    purrr::map(unique)
details_Name <- sapply(
    details_Name[!sapply(details_Name, purrr::is_empty)],
    paste,
    collapse = "; "
) %>%
    gsub("long_terminal_repeat", "LTR", .) %>%
    gsub("LTR_retrotranpoon", "RT", .) %>%
    gsub("tranpoable_element_gene", "TE_gene", .) %>%
    gsub("peudogene", "PG", .)

wrt_Q_all_agg_chr_strand$Name <- details_Name
wrt_Q_all_agg_chr_strand$Alias <- details_Alias
wrt_Q_all_agg_chr_strand$n_types <- ifelse(
    grepl(" ", wrt_Q_all_agg_chr_strand$Alias, fixed = TRUE),
    stringr::str_count(wrt_Q_all_agg_chr_strand$Alias, " ") + 1,
    1
)
wrt_Q_all_agg_chr_strand$n_features <- ifelse(
    grepl(";", wrt_Q_all_agg_chr_strand$ID, fixed = TRUE),
    stringr::str_count(wrt_Q_all_agg_chr_strand$ID, ";") + 1,
    1
)

wrt_Q_all <- wrt_Q_all_agg_chr_strand
wrt_Q_all$ID <- gsub("; ", "_", wrt_Q_all$ID)
wrt_Q_all$Ontology_term <- wrt_Q_all$Ontology_term %>%
    gsub("; ", "_", .) %>%
    gsub(", ", "-", .)
wrt_Q_all$Name <- wrt_Q_all$Name %>%
    gsub(": ", "-", .) %>%
    gsub("; ", "_", .) %>%
    gsub("TE_gene", "TE", .)
# wrt_Q_all %>%
#     dplyr::group_by(strand) %>%
#     dplyr::summarize(n = dplyr::n())

rm(wrt_Q_all_agg_chr_strand, wrt_Q_all_group_chr_strand, details_Alias, details_Name)

```

