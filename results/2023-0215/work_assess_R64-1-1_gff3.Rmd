---
title: "work_assess_R64-1-1_gff3.Rmd"
output: html_notebookauthor: "KA"
email: "kalavatt@fredhutch.org"
output:
    html_notebook:
        toc: yes
        toc_float: true
---
<br />

Want to see how this file from SGD differs from the Ensembl 108 file we have been using
`#TODO` Include file names, more info

## Get situated
### Code
<details>
<summary><i>Code: Get situated</i></summary>
```{r}
#!/usr/bin/env Rscript

library(GenomicRanges)
library(IRanges)
library(plyr)
library(readxl)
library(rtracklayer)
library(tidyverse)

options(scipen = 999)
options(ggrepel.max.overlaps = Inf)

if(stringr::str_detect(getwd(), "kalavattam")) {
    p_local <- "/Users/kalavattam/Dropbox/FHCC"
} else {
    p_local <- "/Users/kalavatt/projects-etc"
}
p_wd <- "2022_transcriptome-construction/results/2023-0215"

setwd(paste(p_local, p_wd, sep = "/"))
getwd()

rm(p_local, p_wd)
```
</details>
<br />
<br />

## Load `gtf`, `gff3` files
### Code
<details>
<summary><i>Code: Load "R64" (`saccharomyces_cerevisiae_R64-1-1_20110208.gff`)</i></summary>
```{r Load "R64", results='hide', message=FALSE, warning=FALSE}
p_SGD <- "./infiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203"
f_SGD <- "saccharomyces_cerevisiae_R64-1-1_20110208.gff"
gff3_SGD <- paste(p_SGD, f_SGD, sep = "/") %>%
    rtracklayer::import() %>%
    tibble::as_tibble() %>%
    dplyr::arrange(seqnames, start) %>%
    dplyr::mutate(seqnames = gsub("chr", "", seqnames))

rm(p_SGD, f_SGD)

p_Ens <- "./infiles_gtf-gff3/already"
f_Ens <- "Saccharomyces_cerevisiae.R64-1-1.108.gff3"
gff3_Ens <- paste(p_Ens, f_Ens, sep = "/") %>%
    rtracklayer::import() %>%
    tibble::as_tibble() %>%
    dplyr::arrange(seqnames, start)

rm(p_Ens, f_Ens)

p_Ens <- "./infiles_gtf-gff3/already"
f_Ens <- "Saccharomyces_cerevisiae.R64-1-1.108.gtf"
gtf_Ens <- paste(p_Ens, f_Ens, sep = "/") %>%
    rtracklayer::import() %>%
    tibble::as_tibble() %>%
    dplyr::arrange(seqnames, start)

rm(p_Ens, f_Ens)
```
</details>
<br />
<br />

## Perform comparisons
### Are the numbers of sn/snoRNA features per `gtf`/`gff3` the same?
#### Code
<details>
<summary><i>Code: Are the numbers of sn/snoRNA features per `gtf`/`gff3` the same?</i></summary>
```{r Are the numbers of sn/snoRNA features per gtf/gff3 the same?, results='hide', message=FALSE, warning=FALSE}
gff3_SGD %>% colnames()
gff3_Ens %>% colnames()
gtf_Ens %>% colnames()

type_gff3_SGD <- gff3_SGD %>%
    dplyr::group_by(type) %>%
    dplyr::summarize(n = dplyr::n())

type_gff3_Ens <- gff3_Ens %>%
    dplyr::group_by(type) %>% 
    dplyr::summarize(n = dplyr::n())

type_gtf_Ens <- gtf_Ens %>%
    dplyr::group_by(type) %>% 
    dplyr::summarize(n = dplyr::n())

biotype_gff3_SGD <- gff3_SGD %>%
    dplyr::group_by(type) %>%
    dplyr::summarize(n = dplyr::n())

biotype_gff3_Ens <- gff3_Ens %>%
    dplyr::group_by(biotype) %>% 
    dplyr::summarize(n = dplyr::n())

biotype_gtf_Ens <- gtf_Ens %>%
    dplyr::group_by(gene_biotype) %>% 
    dplyr::summarize(n = dplyr::n())
```
</details>
<br />

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
#  Initialize function --------------------------------------------------------
`%notin%` <- Negate(`%in%`)


#  For the SGD gff3, subset by column "type" entry "gene" ---------------------
z_gff3_SGD_genes <- gff3_SGD %>%
    dplyr::filter(type == "gene")

#  Tally number of genes per chromosome
# z_gff3_SGD_genes %>%
#     dplyr::group_by(seqnames) %>%
#     dplyr::summarize(n = dplyr::n())

z_gff3_Ens_genes_summary <- gff3_Ens %>%
    dplyr::filter(type == "gene") %>%
    dplyr::group_by(seqnames) %>%
    dplyr::summarize(n = dplyr::n())

z_gff3_Ens_genes_summary_sum <- sum(z_gff3_Ens_genes_summary$n)


#  For the Ensembl gff3, subset by column "type" entry "gene" -----------------
z_gff3_Ens_genes <- gff3_Ens %>%
    dplyr::filter(type == "gene") %>%
    dplyr::group_by(seqnames)

z_gff3_SGD_genes$ID %notin%
    stringr::str_remove(z_gff3_Ens_genes$ID, "gene:") %>%
table()


#  Find gene IDs in SGD not in Ensembl ----------------------------------------
z_gff3_SGD_genes[z_gff3_SGD_genes$ID %notin%
        stringr::str_remove(z_gff3_Ens_genes$ID, "gene:"), ]$ID
# [1] "YER109C" "YFL057C" "YFL056C" "YOR031W" "R0010W"  "R0020C"  "R0030W"  "R0040C"

#  (column ID) ------------------------
c("YER109C", "YFL057C", "YFL056C", "YOR031W") %in%
    stringr::str_remove(gff3_Ens$ID, "gene:|CDS:|transcript:")
# [1] FALSE FALSE  TRUE FALSE

gff3_Ens[stringr::str_remove(gff3_Ens$ID, "gene:|CDS:|transcript:") %in%
    c("YER109C", "YFL057C", "YFL056C", "YOR031W"), ]

#  (column protein_ID) ----------------
c("YER109C", "YFL057C", "YFL056C", "YOR031W") %in% gff3_Ens$protein_id
# [1] FALSE FALSE FALSE FALSE

# gff3_Ens[gff3_Ens$protein_id %in%
#     c("YER109C", "YFL057C", "YFL056C", "YOR031W"), ]

#  (column gene_id) -------------------
c("YER109C", "YFL057C", "YFL056C", "YOR031W") %in% gff3_Ens$gene_id
# [1] FALSE FALSE TRUE FALSE

gff3_Ens[gff3_Ens$gene_id %in%
    c("YER109C", "YFL057C", "YFL056C", "YOR031W"), ]

#  (column transcript_id) -------------
c("YER109C", "YFL057C", "YFL056C", "YOR031W") %in% gff3_Ens$transcript_id
# [1] FALSE FALSE TRUE FALSE

gff3_Ens[gff3_Ens$transcript_id %in%
    c("YER109C", "YFL057C", "YFL056C", "YOR031W"), ]


#  Find any rows associated with "YER109C", "YFL057C", "YFL056C", "YOR031W" ---
library(data.table)
gff3_Ens[apply(gff3_Ens, 1, function(x) any(x %like% "YER109C")), ]  # 0 rows
gff3_Ens[apply(gff3_Ens, 1, function(x) any(x %like% "YFL057C")), ]  # 1 row (in row for "YFL056C")
gff3_Ens[apply(gff3_Ens, 1, function(x) any(x %like% "YFL056C")), ]  # 3 rows
gff3_Ens[apply(gff3_Ens, 1, function(x) any(x %like% "YOR031W")), ]  # 0 rows
```
</details>
<br />

"YER109C", "YFL057C", "YFL056C", and "YOR031W" are on, respectively, chromosomes V, VI, VI, and XV; "R0010W", "R0020C", "R0030W", and "R0040C" are on "2-micron". Thus, "YER109C", "YFL057C", "YFL056C", and "YOR031W" are apparently valid genes that we *may* care about that are not&mdash;for some reason&mdash;associated with IDs in the Ensembl annotation.

"YER109C", "YFL057C", "YFL056C", and "YOR031W" are not associated with `protein_ID` assignments in `gff3_Ens`; however, in `gff3_Ens`, "YFL056C" appears to be associated with `type` "pseudogene" and "pseudogene_transcript", `biotype` "pseudogene", and corresponding `gene_id` and `transcript_id` entries; the other genes&mdash;"YER109C", "YFL057C", and "YOR031W"&mdash;are not.

"YFL056C" is associated with three rows in `gff3_Ens`: `type`s "pseudogene", "pseudogenic_transcript", and "exon".

"YFL057C" is associated with the "YFL056C" `type` "pseudogene" row (it's in the `description` column)

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
#  repeat region --------------------------------------------------------------
z_gff3_SGD_repeat_region <- gff3_SGD %>%
    dplyr::filter(type == "repeat_region")

z_rr_y_NA <- z_gff3_SGD_repeat_region[is.na(z_gff3_SGD_repeat_region$ID), ]
z_rr_n_NA <- z_gff3_SGD_repeat_region[!is.na(z_gff3_SGD_repeat_region$ID), ]

z_rr_y_NA$Parent %>% unlist()
#  [1] "TEL02L-YP"  "TEL04R-YP"  "TEL05L-YP"  "TEL05R-YP"  "TEL06L-YP"  "TEL07R-YP"  "TEL08L-YP"  "TEL08R-YP"  "TEL09L-YP"  "TEL10L-YP"  "TEL12L-YP1" "TEL12L-YP2" "TEL12R-YP2" "TEL12R-YP1"
# [15] "TEL13L-YP"  "TEL14L-YP"  "TEL15R-YP"  "TEL16L-YP"  "TEL16R-YP"

z_rr_n_NA$Parent %>% unlist()
# character(0)


#  telomere -------------------------------------------------------------------
z_gff3_SGD_telomere <- gff3_SGD %>%
    dplyr::filter(type == "telomere")

z_tel_y_NA <- z_gff3_SGD_telomere[is.na(z_gff3_SGD_telomere$ID), ]
z_tel_n_NA <- z_gff3_SGD_telomere[!is.na(z_gff3_SGD_telomere$ID), ]

table(z_tel_n_NA$end %in% z_rr_n_NA$end)
# TRUE
#   32

table(z_tel_n_NA$start %in% z_rr_n_NA$start)
# TRUE
#   32

gr_tel_n_NA <- GenomicRanges::GRanges(z_tel_n_NA)
gr_rr_n_NA <- GenomicRanges::GRanges(z_rr_n_NA)

IRanges::countOverlaps(gr_tel_n_NA, gr_rr_n_NA)
tmp <- IRanges::findOverlaps(gr_tel_n_NA, gr_rr_n_NA) %>% tibble::as_tibble()
rm(tmp)

IRanges::countOverlaps(gr_rr_n_NA, gr_tel_n_NA)
tmp <- IRanges::findOverlaps(gr_rr_n_NA, gr_tel_n_NA) %>% tibble::as_tibble()
rm(tmp)


#  centromere -----------------------------------------------------------------
z_gff3_SGD_centromere <- gff3_SGD %>%
    dplyr::filter(type == "centromere")

gr_cen <- GenomicRanges::GRanges(z_gff3_SGD_centromere)

IRanges::countOverlaps(gr_cen, gr_tel_n_NA)
IRanges::countOverlaps(gr_cen, gr_rr_n_NA)

# rm(z_rr_n_NA, z_rr_y_NA, z_tel_n_NA, z_tel_y_NA)
# rm(z_gff3_SGD_repeat_region)
# rm(z_gff3_SGD_telomere)
```
</details>
<br />

For `type` "repeat_region", go with `!is.na()`, which encompasses the ranges in `is.na()`.

All of the ranges in `z_rr_n_NA` overlap the ranges in `z_tel_n_NA`. There are no overlaps between `z_gff3_SGD_centromere` and `z_rr_n_NA` (which might be expected), nor are there overlaps between `z_gff3_SGD_centromere` and `z_tel_n_NA` (which are not expected).

`#CONCLUSION` Thus, I think I should exclude `type` "repeat_region" in favor of `type` "telomere". "Centromere" can be included without any problems with any features, I think.

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
z_gff3_SGD_ncRNA <- gff3_SGD %>%
    dplyr::filter(type == "ncRNA")
z_gff3_SGD_noncoding_exon <- gff3_SGD %>%
    dplyr::filter(type == "noncoding_exon")
z_gff3_SGD_tRNA <- gff3_SGD %>%
    dplyr::filter(type == "tRNA")
z_gff3_SGD_snRNA_snoRNA <- gff3_SGD %>%
    dplyr::filter(type == "snRNA" | type == "snoRNA")
z_gff3_SGD_rRNA <- gff3_SGD %>%
    dplyr::filter(type == "rRNA")

z_gff3_noncoding_etc <- gff3_SGD %>%
    dplyr::filter(
        type == "ncRNA" |
        type == "noncoding_exon" |
        type == "tRNA" |
        type == "snoRNA" |
        type == "snRNA" |
        type == "rRNA"
    )

gr_noncoding_exon <- GenomicRanges::GRanges(z_gff3_SGD_noncoding_exon)
gr_noncoding_ncRNA <- GenomicRanges::GRanges(z_gff3_SGD_ncRNA)
gr_tRNA <- GenomicRanges::GRanges(z_gff3_SGD_tRNA)
gr_snRNA_snoRNA <- GenomicRanges::GRanges(z_gff3_SGD_snRNA_snoRNA)
gr_rRNA <- GenomicRanges::GRanges(z_gff3_SGD_rRNA)

sum_1 <- IRanges::countOverlaps(gr_noncoding_exon, gr_noncoding_ncRNA) %>% sum()
tmp_1 <- IRanges::findOverlaps(gr_noncoding_exon, gr_noncoding_ncRNA) %>%
    tibble::as_tibble()

sum_2 <- IRanges::countOverlaps(gr_noncoding_exon, gr_tRNA) %>% sum()
tmp_2 <- IRanges::findOverlaps(gr_noncoding_exon, gr_tRNA) %>%
    tibble::as_tibble()

sum_3 <- IRanges::countOverlaps(gr_noncoding_exon, gr_snRNA_snoRNA) %>% sum()
tmp_3 <- IRanges::findOverlaps(gr_noncoding_exon, gr_snRNA_snoRNA) %>%
    tibble::as_tibble()

sum_4 <- IRanges::countOverlaps(gr_noncoding_exon, gr_rRNA) %>% sum()
tmp_4 <- IRanges::findOverlaps(gr_noncoding_exon, gr_rRNA) %>%
    tibble::as_tibble()

z_gff3_SGD_noncoding_exon[
    z_gff3_SGD_noncoding_exon$Name %notin%
        z_gff3_SGD_noncoding_exon[c(tmp_1$queryHits, tmp_2$queryHits, tmp_3$queryHits), ]$Name, 
]

nrow(z_gff3_SGD_noncoding_exon) - (sum_1 + sum_2 + sum_3)

z_gff3_SGD_noncoding_exon[tmp_1$queryHits, ]
z_gff3_SGD_noncoding_exon[tmp_2$queryHits, ]
z_gff3_SGD_noncoding_exon[tmp_3$queryHits, ]
z_gff3_SGD_noncoding_exon[tmp_4$queryHits, ]

rm(
    z_gff3_SGD_ncRNA, z_gff3_SGD_noncoding_exon, z_gff3_SGD_tRNA,
    z_gff3_SGD_snRNA_snoRNA, z_gff3_SGD_rRNA
)
```
</details>
<br />

`#CONCLUSION` We can exclude `type` "noncoding exon"&mdash;these will be included in "ncRNA", "tRNA", "snoRNA", "snRNA", "rRNA". I think they will not be included with anything else.
`#CONCLUSION` So, here's what to include (so far) for `type`:
- "centromere"
- "genes" (`#MAYBE` stratified by `orf_classification`)
- "ncRNA"
- "rRNA"
- "snRNA"
- "snoRNA"
- "telomere"
- "tRNA"

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
convert_character_0_NA <- function(x) {
    z <- lapply(
        x, function(y) if(identical(y, character(0))) NA_character_ else y
    ) %>%
        unlist()
    
    return(z)
}


flatten_elements_to_one <- function(x) {
    # For character list elements with two or more subelements, collapse the
    # subelements into a single character element
    # 
    # :param x: list
    # :return: character vector of collapsed list elements (list e)
    
    l_collapsed <- x[lengths(x) >= 2] %>% length()
    collapsed <- vector(mode = "character", length = l_collapsed)
    for(i in 1:l_collapsed) {
        # i <- 1
        # cat(i, "\n")
        # cat(x[lengths(x) >= 2][[i]], "\n")
        collapsed[i] <- stringr::str_c(
            x[lengths(x) >= 2][[i]],
            collapse = ", "
        )
    }
    
    return(collapsed)
}


process_list_column <- function(x) {
    x[lengths(x) == 0] <- NA_character_
    if(length(x[lengths(x) >= 2]) != 0) {
        x[lengths(x) >= 2] <- x[lengths(x) >= 2] %>% flatten_elements_to_one()
    }
    y <- x %>% unlist()
    return(y)
}


#  Load tibbles for features ----------
z_gff3_SGD_ARS <- gff3_SGD %>%
    dplyr::filter(type == "ARS")
z_gff3_SGD_LTR <- gff3_SGD %>%
    dplyr::filter(type == "long_terminal_repeat")
z_gff3_SGD_LTR_retrotransposon <- gff3_SGD %>%
    dplyr::filter(type == "LTR_retrotransposon")
z_gff3_SGD_TE_gene <- gff3_SGD %>%
    dplyr::filter(type == "transposable_element_gene")


#  Unlist column Note -----------------
z_gff3_SGD_ARS$Note <- unlist(z_gff3_SGD_ARS$Note)
z_gff3_SGD_LTR$Note <- unlist(z_gff3_SGD_LTR$Note)
z_gff3_SGD_LTR_retrotransposon$Note <- unlist(z_gff3_SGD_LTR_retrotransposon$Note)
z_gff3_SGD_TE_gene$Note <- unlist(z_gff3_SGD_TE_gene$Note)


#  Unlist column Parent ---------------
z_gff3_SGD_ARS$Parent <- convert_character_0_NA(z_gff3_SGD_ARS$Parent)
z_gff3_SGD_LTR$Parent <- convert_character_0_NA(z_gff3_SGD_LTR$Parent)
z_gff3_SGD_LTR_retrotransposon$Parent <- convert_character_0_NA(z_gff3_SGD_LTR_retrotransposon$Parent)
z_gff3_SGD_TE_gene$Parent <- convert_character_0_NA(z_gff3_SGD_TE_gene$Parent)


#  Unlist column Alias ----------------
z_gff3_SGD_ARS$Alias <- process_list_column(z_gff3_SGD_ARS$Alias)
z_gff3_SGD_LTR$Alias <- process_list_column(z_gff3_SGD_LTR$Alias)
z_gff3_SGD_LTR_retrotransposon$Alias <- process_list_column(z_gff3_SGD_LTR_retrotransposon$Alias)
z_gff3_SGD_TE_gene$Alias <- process_list_column(z_gff3_SGD_TE_gene$Alias)


#  Unlist column Ontology_term --------
z_gff3_SGD_ARS$Ontology_term <- process_list_column(z_gff3_SGD_ARS$Ontology_term)
z_gff3_SGD_LTR$Ontology_term <- process_list_column(z_gff3_SGD_LTR$Ontology_term)
z_gff3_SGD_LTR_retrotransposon$Ontology_term <- process_list_column(z_gff3_SGD_LTR_retrotransposon$Ontology_term)
z_gff3_SGD_TE_gene$Ontology_term <- process_list_column(z_gff3_SGD_TE_gene$Ontology_term)


#  Check tibbles ----------------------
z_gff3_SGD_ARS
z_gff3_SGD_LTR
z_gff3_SGD_LTR_retrotransposon
z_gff3_SGD_TE_gene

z_gff3_SGD_ARS %>%
    dplyr::group_by(Note) %>%
    dplyr::summarize(n = dplyr::n())

z_gff3_SGD_LTR %>%
    dplyr::group_by(Note) %>%
    dplyr::summarize(n = dplyr::n())

z_gff3_SGD_LTR_retrotransposon %>%
    dplyr::group_by(Note) %>%
    dplyr::summarize(n = dplyr::n())

z_gff3_SGD_TE_gene %>%
    dplyr::group_by(Note) %>%
    dplyr::summarize(n = dplyr::n())


#  ------
gr_ARS <- GenomicRanges::GRanges(z_gff3_SGD_ARS)
gr_LTR <- GenomicRanges::GRanges(z_gff3_SGD_LTR)
gr_LTR_retrotransposon <- GenomicRanges::GRanges(z_gff3_SGD_LTR_retrotransposon)
gr_TE_gene <- GenomicRanges::GRanges(z_gff3_SGD_TE_gene)

#  1 ----
z_gff3_SGD_LTR %>% dplyr::arrange(seqnames, start)
z_gff3_SGD_LTR_retrotransposon %>% dplyr::arrange(seqnames, start)

sum_1 <- IRanges::countOverlaps(gr_LTR, gr_LTR_retrotransposon) %>% sum()
tmp_1 <- IRanges::findOverlaps(gr_LTR, gr_LTR_retrotransposon) %>%
    tibble::as_tibble()

z_gff3_SGD_LTR[tmp_1$queryHits, ]
z_gff3_SGD_LTR_retrotransposon[tmp_1$subjectHits, ]

z_gff3_SGD_LTR_retrotransposon[seq(1, nrow(z_gff3_SGD_LTR_retrotransposon)) %notin% unique(tmp_1$subjectHits), ]

#  2 -----
z_gff3_SGD_LTR %>% dplyr::arrange(seqnames, start) # %>% nrow()
z_gff3_SGD_TE_gene %>% dplyr::arrange(seqnames, start)

sum_2 <- IRanges::countOverlaps(gr_LTR, gr_TE_gene) %>% sum()
tmp_2 <- IRanges::findOverlaps(gr_LTR, gr_TE_gene) %>%
    tibble::as_tibble()

z_gff3_SGD_LTR[tmp_2$queryHits, ]
z_gff3_SGD_TE_gene[tmp_2$subjectHits, ]

z_gff3_SGD_LTR[seq(1, nrow(z_gff3_SGD_LTR)) %notin% unique(tmp_2$subjectHits), ] %>% nrow()

#  3 -----
z_gff3_SGD_LTR_retrotransposon %>% dplyr::arrange(seqnames, start) # %>% nrow()
z_gff3_SGD_TE_gene %>% dplyr::arrange(seqnames, start) # %>% nrow()

sum_3 <- IRanges::countOverlaps(gr_LTR_retrotransposon, gr_TE_gene) %>% sum()
tmp_3 <- IRanges::findOverlaps(gr_LTR_retrotransposon, gr_TE_gene) %>%
    tibble::as_tibble()

z_gff3_SGD_LTR_retrotransposon[tmp_3$queryHits, ]
z_gff3_SGD_TE_gene[tmp_3$subjectHits, ]

z_gff3_SGD_LTR_retrotransposon[seq(1, nrow(z_gff3_SGD_LTR_retrotransposon)) %notin% unique(tmp_3$subjectHits), ]

#  4 -----
z_gff3_SGD_LTR
z_gff3_SGD_ARS

sum_4 <- IRanges::countOverlaps(gr_LTR, gr_ARS) %>% sum()
tmp_4 <- IRanges::findOverlaps(gr_LTR, gr_ARS) %>%
    tibble::as_tibble()

z_gff3_SGD_LTR[tmp_4$queryHits, ]
z_gff3_SGD_ARS[tmp_4$subjectHits, ]

z_gff3_SGD_LTR[seq(1, nrow(z_gff3_SGD_LTR)) %notin% unique(tmp_4$subjectHits), ]

#  ------
z_gff3_SGD_LTR[tmp_4$queryHits, ]
z_gff3_SGD_ARS[tmp_4$subjectHits, ]
z_gff3_SGD_LTR[seq(1, nrow(z_gff3_SGD_LTR)) %notin% tmp_4$queryHits, ]
z_gff3_SGD_ARS[seq(1, nrow(z_gff3_SGD_ARS)) %notin% tmp_4$subjectHits, ]
```
</details>
<br />

Almost all `z_gff3_SGD_LTR_retrotransposon` overlaps `z_gff3_SGD_LTR`&mdash;all except IV 878303 884220	5918 - SGD LTR_retrotransposon ... YDRCTy1-2 SGD:S000006860 YDRCTy1-2 ...

82 out of 89 TEs (`z_gff3_SGD_TE_gene`) at least partially overlap 301 out of 383 LTRs (`z_gff3_SGD_LTR`)

All 89 TEs (`z_gff3_SGD_TE_gene`) at least partially overlap all but one row in `z_gff3_SGD_LTR_retrotransposon`

20 LTRs overlap ARSs

### ...
#### Code
<details>
<summary><i>Code: ... </i></summary>
```{r}
gff3_mystery <- gff3_SGD %>%
    dplyr::filter(
        type == "nucleotide_match" |
        type == "binding_site" |
        type == "region" |
        type == "five_prime_UTR_intron" |
        type == "gene_cassette" |
        type == "insertion" |
        type == "external_transcribed_spacer_region" |
        type == "internal_transcribed_spacer_region"
    )


#  Unlist column Note
gff3_mystery$Note <- process_list_column(gff3_mystery$Note)

#  Unlist column Parent
gff3_mystery$Parent <- process_list_column(gff3_mystery$Parent)

#  Unlist column Alias
gff3_mystery$Alias <- process_list_column(gff3_mystery$Alias)

#  Unlist column Ontology_term
gff3_mystery$Ontology_term <- process_list_column(gff3_mystery$Ontology_term)


gff3_SGD %>% dplyr::filter(dbxref == "SGD:S000029655")
gff3_SGD %>% dplyr::filter(ID == "HMR")
gff3_SGD %>% dplyr::filter(Name == "YJR027W")
gff3_SGD %>% dplyr::filter(Name == "YBL092W")

# gff3_SGD %>% dplyr::filter(type == "intron")  # Yeah, let's exclude introns, which will be included along with gene or tRNA (or etc.) entries
```
</details>
<br />

We can exclude `type` "nucleotide_match", which mostly seem to be parts of telomere and ARS features

We can exclude `type` "binding_site", which are all within telomere features

We can also exclude `type` "region", which seem to be encompassed in other features

Retain `type` "five_prime_UTR_intron"

~~Retain `type` "gene_cassette"~~ After discussion with Toshi, we realize that these features will be encompassed by other features (e.g., within `type` "gene"), so we can exclude `type` "gene_cassette"

~~Retain `type` "external_transcribed_spacer_region" and "internal_transcribed_spacer_region"~~ Actually, don't b/c these are already covered by `type` "rRNA"


## Survey all of the notes I have taken so far and make decisions
Go with the SGD annotation for this work.

We should not remove any entries from `type` "gene" despite there being an extra four chromosomal genes in the SGD annotation versus the Ensembl R64-1-1 annotation.

We should exclude `type` "repeat_region" in favor of `type` "telomere". "Centromere" can be included without any problems with any features, I think.

We can exclude `type` "noncoding exon" since these will be included in variously "ncRNA", "tRNA", "snoRNA", "snRNA", "rRNA".

So, here's what to include for `type`:
- "ARS" (both strands)
- "centromere" (both strands)
- "five_prime_UTR_intron" (antisense too)
- "gene" (antisense too)
- "ncRNA" (antisense too)
- "pseudogene" (antisense too)
- "rRNA" (antisense too)
- "snRNA" (antisense too)
- "snoRNA" (antisense too)
- "telomere" (both strands)
- "transposable_element" (made from collapsing/merging "long_terminal_repeat", "LTR_retrotransposon", and "transposable_element_gene") (antisense too)
- "tRNA" (antisense too)


And here's what not to include for `type`:
- "binding_site"
- "CDS"
- "chromosome"
- "external_transcribed_spacer_region" (already in `type` "rRNA")
- "gene_cassette"
- "insertion"
- "internal_transcribed_spacer_region" (already in `type` "rRNA")
- "intron"
- "noncoding_exon"
- "nucleotide_match"
- "region"
- "repeat_region"

```{r}
# stackoverflow.com/questions/6190051/how-can-i-remove-all-objects-but-one-from-the-workspace-in-r
rm(list = setdiff(ls(), "gff3_SGD"))


#  Initialize functions -------------------------------------------------------
# `%+=%` <- function(x, y) eval.parent(substitute(x <- x + y))
# # stackoverflow.com/questions/5738831/r-plus-equals-and-plus-plus-equivalent-from-c-c-java-etc


# detect_overlap <- function(x, y) {
#     # Detect overlaps
#     # :param x: row number <numeric>
#     # :param y: range start and end columns/vectors <numeric>
#     # :return z: Boolean <0 or 1>
#     z <- ifelse(x[2] >= y[1], 1, 0)
#     return(z)
# }


# nonOverlappingGR <- function(
#     #' Retrieve a non-overlapping set of regions from a `GenomicRanges` object
#     #' 
#     #' This function returns a `GRanges` object containing a non-overlapping set 
#     #' regions derived from a supplied `GenomicRanges` object. Taken from
#     #' github.com/GreenleafLab/ArchR/blob/master/R/GRangesUtils.R#L60
#     #'
#     #' @param gr A `GRanges` object.
#     #' @param by The name of a column in `mcols(gr)` that should be used to
#     #' determine how overlapping regions should be resolved.
#     #' The resolution of overlapping regions also depends on `decreasing`. For
#     #' example, if a column named "score" is used for `by`, `decreasing = TRUE`
#     #' means that the highest "score" in the overlap will be retained and
#     #' `decreasing = FALSE` means that the lowest "score" in the overlap will
#     #' be retained.
#     #' @param decreasing A boolean value indicating whether the values in the
#     #' column indicated via `by` should be ordered in decreasing order. If
#     #' `TRUE`, the higher value in `by` will be retained.
#     #' @param verbose A boolean value indicating whether the output should
#     #' include extra reporting.
#     #' @export
# 	gr = NULL, 
# 	by = "score", 
# 	decreasing = TRUE, 
# 	verbose = FALSE
#   ){
#     # .validInput(input = gr, name = "gr", valid = c("GRanges"))
#     # .validInput(input = by, name = "by", valid = c("character"))
#     # .validInput(input = decreasing, name = "decreasing", valid = c("boolean"))
#     # .validInput(input = verbose, name = "verbose", valid = c("boolean"))
#     
#     stopifnot(by %in% colnames(mcols(gr)))
#     
#     #  Cluster GRanges into islands using reduce and then select based on input
#     .clusterGRanges <- function(
#         gr = NULL,
#         filter = TRUE,
#         by = "score",
#         decreasing = TRUE
#     ){
#         gr <- sort(sortSeqlevels(gr))
#         r <- GenomicRanges::reduce(gr, min.gapwidth = 0L, ignore.strand = TRUE)
#         o <- findOverlaps(gr, r, ignore.strand = TRUE)
#         mcols(gr)$cluster <- subjectHits(o)
#         gr <- gr[order(mcols(gr)[, by], decreasing = decreasing), ]
#         gr <- gr[!duplicated(mcols(gr)$cluster), ]
#         gr <- sort(sortSeqlevels(gr))
#         mcols(gr)$cluster <- NULL
#         return(gr)
#     }
#     
#     if(verbose) message("Converging", appendLF = FALSE)
#     
#     i <-  0
#     grConverge <- gr
#     while(length(grConverge) > 0) {
#         if(verbose){
#             message(".", appendLF = FALSE)
#         }
#         i <-  i + 1
#         grSelect <- .clusterGRanges(
#             gr = grConverge, 
#             filter = TRUE, 
#             by = by, 
#             decreasing = decreasing
#         )
#         
#         grConverge <- subsetByOverlaps(
#             grConverge,
#             grSelect, 
#             invert=TRUE, 
#             ignore.strand = TRUE
#         )  # Blacklist selected gr
#         
#         if(i == 1){  # If i is 1, then set gr_all to clustered
#             grAll <- grSelect
#         } else {
#             grAll <- c(grAll, grSelect)
#         } 
#     
#     }
#     message(sprintf("Converged after %s iterations!", i))
#     
#     if(verbose) {
#         message("\nSelected ", length(grAll), " from ", length(gr))
#     }
#     grAll <- sort(sortSeqlevels(grAll))
#     
#     return(grAll)
# }


flatten_elements_to_one <- function(x) {
    # For character list elements with two or more subelements, collapse the
    # subelements into a single character element
    # 
    # :param x: list
    # :return: character vector of collapsed list elements (list e)
    
    l_collapsed <- x[lengths(x) >= 2] %>% length()
    collapsed <- vector(mode = "character", length = l_collapsed)
    for(i in 1:l_collapsed) {
        # i <- 1
        # cat(i, "\n")
        # cat(x[lengths(x) >= 2][[i]], "\n")
        collapsed[i] <- stringr::str_c(
            x[lengths(x) >= 2][[i]],
            collapse = ", "
        )
    }
    
    return(collapsed)
}


process_list_column <- function(x) {
    x[lengths(x) == 0] <- NA_character_
    if(length(x[lengths(x) >= 2]) != 0) {
        x[lengths(x) >= 2] <- x[lengths(x) >= 2] %>% flatten_elements_to_one()
    }
    y <- x %>% unlist()

    return(y)
}


write_gtf <- function(x, y) {
    # ...
    # :param x: tibble
    # :param y: outfile
    # :return: NA
    readr::write_tsv(
        x,
        y,
        col_names = FALSE,
        quote = "none",
        escape = "none"
    )
}


format_SGD_tibble <- function(x) {
    # ...
    # :param x: tibble
    # :return y: tibble in a basic gtf/gff2 format
    y <- x %>%
        dplyr::arrange(seqnames, start) %>%
        dplyr::rename(seqname =  seqnames) %>%
        dplyr::filter(seqname != "2-micron") %>%
        dplyr::mutate(feature = "feature", score = ".", frame = ".") %>%
        dplyr::relocate(c(source, feature), .after = seqname) %>%
        dplyr::relocate(c(score, strand, frame), .after = end) %>%
        dplyr::mutate(
            attribute = paste(
                paste0("gene_id \"", ID, "\""),
                paste0("transcript_id \"", ID, "\""),
                paste0("type \"", type, "\""),
                paste0("orf_classification \"", orf_classification, "\""),
                paste0("source_id \"", gsub("SGD:", "", dbxref), "\""),
                sep = "; "
            )
        ) %>%
        dplyr::select(-c(
            Alias, dbxref, gene, ID, Name, Note, Ontology_term,
            orf_classification, type, width
        ))
    
    return(y)
}


#  Isolate the features that we (may) want to obtain antisense counts ---------
features_etc <- gff3_SGD %>%
    dplyr::filter(
        type == "five_prime_UTR_intron" |
        type == "gene" |
        type == "ncRNA" |
        type == "pseudogene" |
        type == "rRNA" |
        type == "snRNA" |
        type == "snoRNA" |
        type == "tRNA"
    ) %>%
    dplyr::filter(
        seqnames != "2-micron" &
        seqnames != "Mito"
    ) %>%
    dplyr::select(-c(Parent, phase, score)) %>%
    dplyr::arrange(seqnames, start, strand)
features_etc$Note <- process_list_column(features_etc$Note)
features_etc$Alias <- process_list_column(features_etc$Alias)
features_etc$Ontology_term <- process_list_column(features_etc$Ontology_term)
features_etc$ID <- features_etc$Name <- ifelse(
    features_etc$type == "five_prime_UTR_intron",
    paste0(features_etc$Name, "_5p"),
    ifelse(
        features_etc$type == "repeat_region",
        paste(
            features_etc$Name,
            paste0(
                features_etc$seqnames, ":",
                features_etc$start, "-",
                features_etc$end
            ),
            sep = "_"
        ),
        features_etc$Name
    )
)

# duplicated(features_etc$Name) %>% table()
# duplicated(features_etc$ID) %>% table()

# features_etc %>%
#     dplyr::group_by(type) %>%
#     dplyr::summarize(n = dplyr::n()) %>%
#     dplyr::arrange(dplyr::desc(n))

# all(features_etc$ID == features_etc$Name)


#  Create a dataframe of features antisense to features in features_etc -------
features_etc_antisense <- features_etc
features_etc_antisense$strand <- ifelse(features_etc_antisense$strand == "+", "-", "+")
features_etc_antisense$source <- "SGD (KA)"
features_etc_antisense$type <- paste("antisense", features_etc_antisense$type, sep = "_")
features_etc_antisense$ID <- features_etc_antisense$Name <- paste(features_etc_antisense$Name, "AS", sep = "_")

# features_etc_antisense %>%
#     dplyr::group_by(strand) %>%
#     dplyr::summarize(n = dplyr::n())


#  Collapse and merge transposable-element and related features ---------------
transposable_elements <- gff3_SGD %>% dplyr::filter(        
    type == "long_terminal_repeat" |
    type == "LTR_retrotransposon" |
    type == "transposable_element_gene"
) %>%
    dplyr::filter(
        seqnames != "2-micron" &
        seqnames != "Mito"
    ) %>%
    dplyr::select(-c(score, phase, Parent)) %>%
    dplyr::arrange(seqnames, start, strand)
transposable_elements$Note <- process_list_column(transposable_elements$Note)
transposable_elements$Alias <- process_list_column(transposable_elements$Alias)
transposable_elements$Ontology_term <- process_list_column(transposable_elements$Ontology_term)
transposable_elements$ID <- transposable_elements$Name <- ifelse(
    transposable_elements$type == "five_prime_UTR_intron",
    paste0(transposable_elements$Name, "_5p"),
    ifelse(
        transposable_elements$type == "repeat_region",
        paste(
            transposable_elements$Name,
            paste0(
                transposable_elements$seqnames, ":",
                transposable_elements$start, "-",
                transposable_elements$end
            ),
            sep = "_"
        ),
        transposable_elements$Name
    )
)

#  Link rows after stratifying for both 'chr' and 'strand'
group_chr_strand <- plyr::ddply(
    transposable_elements,
    c("seqnames", "strand"),
    function(x) { 
        #  Check if a record should be linked with the previous record
        y <- c(NA, x$end[-nrow(x)])
        z <- ifelse(is.na(y), 0, y)
        z <- cummax(z)
        z[is.na(y)] <- NA
        x$previous_end <- z
        
        return(x)
    }
)
group_chr_strand$new_group <- is.na(group_chr_strand$previous_end) | 
    (group_chr_strand$start >= group_chr_strand$previous_end)
group_chr_strand$group <- cumsum(group_chr_strand$new_group)
group_chr_strand <- group_chr_strand %>%
    dplyr::mutate(
        type_ID = paste0(type, ": ", ID)
    )


#  Aggregate the data
agg_chr_strand <- plyr::ddply(
    group_chr_strand,
    .(seqnames, strand, group),
    plyr::summarize, 
    start = min(start),
    end = max(end),
    width = (end - start) + 1,
    ID = paste0(ID, collapse = "; "),
    dbxref = paste0(dbxref, collapse = "; "),
    Name = paste0(type_ID, collapse = "; "),
    Note = paste0(Note, collapse = "; "),
    Ontology_term = paste0(Ontology_term, collapse = "; "),
    Alias = paste0(type, collapse = "; ")
) %>%
    dplyr::mutate(
        strand = strand,
        source = "SGD (KA)",
        type = "transposable_element",
        orf_classification = NA_character_,
        gene = NA_character_
    ) %>%
    dplyr::select(-group) %>% 
    dplyr::arrange(seqnames, start, strand) %>%
    dplyr::relocate(c(
        seqnames, start, end, width, strand, source, type, ID, dbxref, Name,
        Note, Ontology_term, orf_classification, Alias, gene
    ))

details_Alias <- agg_chr_strand$Alias %>%
    stringr::str_remove_all("s") %>%
    stringr::str_split("; ") %>%
    purrr::map(sort) %>%
    purrr::map(unique)
details_Alias <- sapply(
    details_Alias[!sapply(details_Alias, purrr::is_empty)],
    paste,
    collapse = " "
) %>%
    gsub("long_terminal_repeat", "LTR", .) %>%
    gsub("LTR_retrotranpoon", "RT", .) %>%
    gsub("tranpoable_element_gene", "TE_gene", .)

details_Name <- agg_chr_strand$Name %>%
    stringr::str_remove_all("s") %>%
    stringr::str_split("; ") %>%
    purrr::map(sort) %>%
    purrr::map(unique)
details_Name <- sapply(
    details_Name[!sapply(details_Name, purrr::is_empty)],
    paste,
    collapse = "; "
) %>%
    gsub("long_terminal_repeat", "LTR", .) %>%
    gsub("LTR_retrotranpoon", "RT", .) %>%
    gsub("tranpoable_element_gene", "TE_gene", .)

agg_chr_strand$Name <- details_Name
agg_chr_strand$Alias <- details_Alias
agg_chr_strand$n_types <- ifelse(
    grepl(" ", agg_chr_strand$Alias, fixed = TRUE),
    stringr::str_count(agg_chr_strand$Alias, " ") + 1,
    1
)
agg_chr_strand$n_features <- ifelse(
    grepl(";", agg_chr_strand$ID, fixed = TRUE),
    stringr::str_count(agg_chr_strand$ID, ";") + 1,
    1
)


#  Make ARS, telomere, and centromere entries for plus and minus strands ------
ARS_etc_plus <- gff3_SGD %>% dplyr::filter(
    type == "ARS" |
    type == "telomere" |
    type == "centromere"
)
ARS_etc_plus$Note <- process_list_column(ARS_etc_plus$Note)
ARS_etc_plus$Parent <- process_list_column(ARS_etc_plus$Parent)
ARS_etc_plus$Alias <- process_list_column(ARS_etc_plus$Alias)
ARS_etc_plus$Ontology_term <- process_list_column(ARS_etc_plus$Ontology_term)
ARS_etc_plus$Name <- ifelse(
    ARS_etc_plus$type == "five_prime_UTR_intron",
    paste0(ARS_etc_plus$Name, "_5p"),
    ifelse(
        ARS_etc_plus$type == "repeat_region",
        paste(
            ARS_etc_plus$Name,
            paste0(ARS_etc_plus$seqnames, ":", ARS_etc_plus$start, "-", ARS_etc_plus$end),
            sep = "_"
        ),
        ARS_etc_plus$Name
    )
)
ARS_etc_plus$ID <- ARS_etc_plus$Name

ARS_etc_minus <- ARS_etc_plus
ARS_etc_plus$strand <- "+"
ARS_etc_minus$strand <- "-"
ARS_etc_plus$ID <- ARS_etc_plus$Name <- paste(ARS_etc_plus$Name, "plus", sep = "_")
ARS_etc_minus$ID <- ARS_etc_minus$Name <- paste(ARS_etc_minus$Name, "minus", sep = "_")


#  Bind dataframes features_etc_sense, ARS_etc_plus, ARS_etc_minus ------------
features_etc_sense <- dplyr::bind_rows(
    features_etc, ARS_etc_plus, ARS_etc_minus
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")

features_etc_sense_antisense <- dplyr::bind_rows(
    features_etc_sense, features_etc_AS
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")

features_etc_antisense <- dplyr::bind_rows(
    features_etc_AS, ARS_etc_plus, ARS_etc_minus
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")


#  Include intergenic annotations in the dataframe ----------------------------
intergenic_plus <- readr::read_tsv(
    "infiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203/NotFeature_R64-1-1_20110203.dataframe.tsv",
    show_col_types = FALSE
) %>%
    dplyr::select(-"...1")

chr_roman <- sapply(
    intergenic_plus$chr,
    function(x) {
        as.character(
            if(grepl("^2-micron$", x)) "2-micron"
            else if(grepl("^Mito$", x)) "Mito"
            else if(grepl("^[1-9]\\d*$", x)) as.roman(x)
        )
    }
)
chr_roman %>%
    as_tibble() %>%
    group_by(value) %>%
    summarize(n = n())

intergenic_plus$chr <- chr_roman
rm(chr_roman)

intergenic_plus %>%
    dplyr::group_by(chr) %>%
    dplyr::summarize(n = dplyr::n()) %>%
    dplyr::arrange(chr)
    
intergenic_plus <- intergenic_plus %>%    
    dplyr::mutate(
        seqnames = chr,
        width = (end - start) + 1,
        source = "SGD (KA)",
        type = "intergenic",
        score =  NA_integer_,
        phase = NA_character_,
        ID = feature,
        dbxref = NA_character_,
        Name = feature,
        Ontology_term = NA_character_,
        orf_classification = NA_character_,
        Parent = NA_character_,
        Alias = coord_pre_n,
        gene = NA_character_
    ) %>%
    dplyr::rename(Note = notes) %>%
    dplyr::select(-c(
        chr, strand_written, category, feature, coord_written, coord_pre_y,
        coord_pre_n, chr_pre_y
    )) %>%
    dplyr::relocate(c(
        seqnames, start, end, width, strand, source, type, score, phase, ID,
        dbxref, Name, Note, Ontology_term, orf_classification, Parent, Alias,
        gene
    ))

intergenic_minus <- intergenic_plus
intergenic_minus$strand <- "-"
intergenic_minus$ID <- paste(intergenic_minus$ID, "minus", sep = "_")
intergenic_plus$ID <- paste(intergenic_plus$ID, "plus", sep = "_")
intergenic_minus$Name <- paste(intergenic_minus$Name, "minus", sep = "_")
intergenic_plus$Name <- paste(intergenic_plus$Name, "plus", sep = "_")
intergenic_minus$Alias <- paste(intergenic_minus$Alias, "minus", sep = "_")
intergenic_plus$Alias <- paste(intergenic_plus$Alias, "plus", sep = "_")
intergenic_minus$Note <- intergenic_minus$Note %>% gsub("between", "Between", .)
intergenic_plus$Note <- intergenic_plus$Note %>% gsub("between", "Between", .)

intergenic <- dplyr::bind_rows(intergenic_plus, intergenic_minus) %>%
    dplyr::arrange(seqnames, start, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")


rm(intergenic_minus, intergenic_plus)


#  Bind dataframes features_etc and intergenic
features_intergenic_sense <- dplyr::bind_rows(
    dplyr::select(features_etc_sense, -c(score, phase)),
    dplyr::select(intergenic, -c(score, phase))
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")

features_intergenic_sense_antisense <- dplyr::bind_rows(
    dplyr::select(features_etc_sense_antisense, -c(score, phase)),
    dplyr::select(intergenic, -c(score, phase))
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")

features_intergenic_antisense <- dplyr::bind_rows(
    dplyr::select(features_etc_antisense, -c(score, phase)),
    dplyr::select(intergenic, -c(score, phase))
) %>%
    dplyr::arrange(seqnames, start, end, strand) %>%
    dplyr::filter(seqnames != "2-micron" & seqnames != "Mito")


write_gtf(
    format_SGD_tibble(features_intergenic_sense),
    "outfiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203/test_features_intergenic_sense.gtf"
)
write_gtf(
    format_SGD_tibble(features_intergenic_antisense),
    "outfiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203/test_features_intergenic_antisense.gtf"
)
write_gtf(
    format_SGD_tibble(features_intergenic_sense_antisense),
    "outfiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203/test_features_intergenic_sense_antisense.gtf"
)


#  Scraps
# all(colnames(test) == colnames(features_etc))  # [1] TRUE
#
# gff3_SGD %>%
#     dplyr::filter(type == "gene") %>%
#     dplyr::group_by(orf_classification) %>%
#     dplyr::summarize(n = dplyr::n())
```

```{r}
write_gtf <- function(x, y) {
    # :param x: tibble
    # :param y: outfile
    # :return: NA
    readr::write_tsv(
        x,
        y,
        col_names = FALSE,
        quote = "none",
        escape = "none"
    )
}


format_NotFeature_tibble <- function(x) {
    y <- x %>%
        dplyr::arrange(chr, start) %>%
        dplyr::mutate(
            source = "SGD (KA)",
            feature = "feature",
            score = ".",
            frame = ".",
            type = "intergenic"
        ) %>%
        dplyr::mutate(
            attribute = paste(
                paste0("gene_id \"", coord_pre_n, "\""),
                paste0("transcript_id \"", coord_pre_n, "\""),
                paste0("type \"", category, "\""),
                paste0("note \"", stringr::str_replace_all(notes, " ", "-"), "\""),
                sep = "; "
            )
        ) %>%
        dplyr::relocate(
            c(chr, source, feature, start, end, score, strand, frame, attribute),
            .before = coord_written
        ) %>%
        dplyr::select(-c(
            coord_written, strand_written, category, notes, coord_pre_y,
            coord_pre_n, chr_pre_y
        ))
    return(y)
}


to_check <- readr::read_tsv(
    "infiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203/NotFeature_R64-1-1_20110203.dataframe.tsv",
    show_col_types = FALSE
) %>%
    dplyr::select(-"...1")
to_check$chr <- to_check$chr %>% utils::as.roman()


write_gtf(
    format_NotFeature_tibble(to_check),
    "outfiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203/NotFeature_R64-1-1_20110203.gtf"
)
```


## Generate a sn/snoRNA-specific `gtf` from "R64"
### Code
<details>
<summary><i>Code: Generate a sn/snoRNA-specific `gtf` from "R64"</i></summary>
```{r}
write_gtf <- function(x, y) {
    # :param x: tibble
    # :param y: outfile
    # :return: NA
    readr::write_tsv(
        x,
        y,
        col_names = FALSE,
        quote = "none",
        escape = "none"
    )
}


format_SGD_tibble <- function(x) {
    # x <- to_include
    # x %>% 
    y <- x %>%
        dplyr::arrange(seqnames, start) %>%
        dplyr::rename(seqname =  seqnames) %>%
        dplyr::filter(seqname != "2-micron") %>%
        dplyr::mutate(feature = "feature", score = ".", frame = ".") %>%
        dplyr::relocate(c(source, feature), .after = seqname) %>%
        dplyr::relocate(c(score, strand, frame), .after = end) %>%
        dplyr::mutate(
            attribute = paste(
                paste0("gene_id \"", ID, "\""),
                paste0("transcript_id \"", ID, "\""),
                # paste0("aliases \"", gsub(" ", "+", Alias), "\""),
                # paste0("aliases \"", Alias, "\""),
                paste0("type \"", type, "\""),
                paste0("orf_classification \"", orf_classification, "\""),
                paste0("source_id \"", gsub("SGD:", "", dbxref), "\""),
                # paste0("go_id \"", gsub(" ", "+", Ontology_term), "\""),
                # paste0("go_id \"", Ontology_term, "\""),
                # paste0("width \"", width, "\""),
                # paste0("note \"", unlist(Note), "\""),
                # paste0(
                #     "note \"",
                #     #+ running htseq-count
                #     gsub(" ", "+", gsub("'", "", unlist(Note))),
                #     "\""
                # ),
                sep = "; "
            )
        ) %>%
        dplyr::select(-c(
            phase, orf_classification, Parent, gene, ID, Name, Alias, type,
            dbxref, width, Ontology_term, width, Note
        ))
    
    return(y)
}

write_gtf(
    format_SGD_tibble(to_include),
    "outfiles_gtf-gff3/comprehensive/S288C_reference_genome_R64-1-1_20110203/test_filtered.gtf"
)
```
</details>
<br />
